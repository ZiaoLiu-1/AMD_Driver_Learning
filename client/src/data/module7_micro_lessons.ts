// ============================================================
// AMD Linux Driver Learning Platform - Module 7 Micro-Lessons
// Module 7: ROCm Kernel Interface (ROCm å†…æ ¸æ¥å£ KFD)
// 4 lessons in 2 groups, ~15-20 min each, total ~70 min
// ============================================================
import type { MicroLessonModule } from './micro_lesson_types';

export const module7MicroLessons: MicroLessonModule = {
  moduleId: 'rocm-kernel',
  groups: [
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Group 7.1: HSA æ¶æ„ä¸ KFD åŸºç¡€
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    {
      id: '7-1',
      number: '7.1',
      title: 'HSA æ¶æ„ä¸ KFD åŸºç¡€',
      titleEn: 'HSA Architecture & KFD Basics',
      icon: 'âš¡',
      description: 'ç†è§£ HSA å¼‚æ„è®¡ç®—æ ‡å‡†ã€KFD åœ¨ amdgpu ä¸­çš„è§’è‰²ã€/dev/kfd è®¾å¤‡èŠ‚ç‚¹çš„è¿ä½œæœºåˆ¶ï¼Œä»¥åŠ KFD ä¸ä¼ ç»Ÿ DRM æ¥å£çš„æ ¸å¿ƒå·®å¼‚ã€‚',
      lessons: [
        // â”€â”€ Lesson 7.1.1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        {
          id: '7-1-1',
          number: '7.1.1',
          title: 'HSA æ¶æ„ä¸ KFD æ¦‚è¿°',
          titleEn: 'HSA Architecture & KFD Overview',
          duration: 18,
          difficulty: 'advanced',
          tags: ['HSA', 'KFD', 'ROCm', '/dev/kfd', 'kfd_process', 'chardev'],
          concept: {
            summary: 'HSAï¼ˆHeterogeneous System Architectureï¼‰æ˜¯ä¸€ç§å¼‚æ„è®¡ç®—æ ‡å‡†ï¼Œå®šä¹‰äº† CPU å’Œ GPU å¦‚ä½•å…±äº«å†…å­˜å’Œåä½œæ‰§è¡Œã€‚KFDï¼ˆKernel Fusion Driverï¼‰æ˜¯ amdgpu é©±åŠ¨ä¸­å®ç° HSA å†…æ ¸æ¥å£çš„å­æ¨¡å—ï¼Œé€šè¿‡ /dev/kfd è®¾å¤‡èŠ‚ç‚¹æš´éœ²è®¡ç®—èƒ½åŠ›ï¼Œä¸ä¼ ç»Ÿçš„ DRM æ¸²æŸ“æ¥å£ /dev/dri/renderD128 å½¢æˆäº’è¡¥ã€‚',
            explanation: [
              'HSA ç”± HSA Foundation åˆ¶å®šï¼ˆAMD æ˜¯åˆ›å§‹æˆå‘˜ï¼‰ï¼Œå…¶æ ¸å¿ƒç†å¿µæ˜¯ï¼šCPU å’Œ GPU ä¸å†æ˜¯"ä¸»ä»å…³ç³»"ï¼Œè€Œæ˜¯å¹³ç­‰çš„è®¡ç®—ä»£ç†ï¼ˆAgentï¼‰ã€‚åœ¨ HSA æ¨¡å‹ä¸­ï¼ŒCPU å’Œ GPU å…±äº«åŒä¸€ä¸ªè™šæ‹Ÿåœ°å€ç©ºé—´ï¼ˆShared Virtual Memoryï¼‰ï¼ŒGPU å¯ä»¥ç›´æ¥è®¿é—® CPU çš„å†…å­˜é¡µï¼Œåä¹‹äº¦ç„¶ã€‚è¿™æ¶ˆé™¤äº†ä¼ ç»Ÿ GPGPU ç¼–ç¨‹ä¸­æ˜¾å¼ cudaMemcpy çš„éœ€æ±‚â€”â€”æ•°æ®ä¸éœ€è¦åœ¨ CPU å’Œ GPU ä¹‹é—´æ‰‹åŠ¨æ‹·è´ã€‚',
              'KFD æ˜¯ HSA åœ¨ Linux å†…æ ¸ä¸­çš„å®ç°ï¼Œä»£ç ä½äº drivers/gpu/drm/amd/amdkfd/ ç›®å½•ã€‚å®ƒä¸æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„é©±åŠ¨ï¼Œè€Œæ˜¯ amdgpu é©±åŠ¨çš„å­æ¨¡å—ã€‚KFD é€šè¿‡ /dev/kfd å­—ç¬¦è®¾å¤‡èŠ‚ç‚¹å‘ç”¨æˆ·ç©ºé—´æš´éœ² HSA åŠŸèƒ½ã€‚ROCm è¿è¡Œæ—¶ï¼ˆlibhsa-runtime64.soï¼‰é€šè¿‡ ioctl è°ƒç”¨ KFD æ¥åˆ›å»ºè®¡ç®—é˜Ÿåˆ—ã€åˆ†é… GPU å†…å­˜ã€ç®¡ç†ä¿¡å·é‡ç­‰ã€‚',
              'ç†è§£ KFD ä¸ DRM æ¥å£çš„åŒºåˆ«è‡³å…³é‡è¦ã€‚DRM æ¥å£ï¼ˆ/dev/dri/card0ã€renderD128ï¼‰é¢å‘å›¾å½¢æ¸²æŸ“å’Œé€šç”¨ GPU è®¿é—®â€”â€”Mesa radeonsi/radv é€šè¿‡å®ƒæäº¤æ¸²æŸ“å‘½ä»¤ã€‚KFD æ¥å£ï¼ˆ/dev/kfdï¼‰ä¸“é—¨é¢å‘ HSA è®¡ç®—â€”â€”ROCm/HIP é€šè¿‡å®ƒæäº¤è®¡ç®—ä»»åŠ¡ã€‚ä¸¤è€…åœ¨å†…æ ¸ä¸­å…±ç”¨ amdgpu é©±åŠ¨çš„åº•å±‚ç¡¬ä»¶è®¿é—®å±‚ï¼Œä½†ä½¿ç”¨ä¸åŒçš„å‘½ä»¤æ ¼å¼ï¼ˆDRM ç”¨ PM4ï¼ŒKFD ç”¨ AQLï¼‰ã€ä¸åŒçš„é˜Ÿåˆ—ç±»å‹ï¼ˆDRM ç”¨ GFX Ringï¼ŒKFD ç”¨ Compute Queueï¼‰ã€ä¸åŒçš„å†…å­˜æ¨¡å‹ï¼ˆDRM ç”¨ GEM/TTMï¼ŒKFD è¿˜é¢å¤–æ”¯æŒ SVMï¼‰ã€‚',
              'KFD çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†å›´ç»• kfd_process ç»“æ„ä½“å±•å¼€ã€‚å½“ç”¨æˆ·ç©ºé—´è¿›ç¨‹ç¬¬ä¸€æ¬¡é€šè¿‡ ioctl è®¿é—® /dev/kfd æ—¶ï¼ŒKFD ä¸ºè¯¥è¿›ç¨‹åˆ›å»ºä¸€ä¸ª kfd_process å®ä¾‹ï¼Œå…¶ä¸­åŒ…å«è¿›ç¨‹çš„ GPU èµ„æºï¼ˆé˜Ÿåˆ—ã€å†…å­˜æ˜ å°„ã€äº‹ä»¶ï¼‰ã€‚è¿™ä¸ªç»“æ„ä½“è´¯ç©¿æ•´ä¸ª KFD å­ç³»ç»Ÿï¼Œæ˜¯ç†è§£ KFD ä»£ç çš„æ ¸å¿ƒæ•°æ®ç»“æ„ã€‚kfd_process æŒæœ‰è¯¥è¿›ç¨‹åœ¨æ‰€æœ‰ GPU ä¸Šçš„ kfd_process_device åˆ—è¡¨â€”â€”æ¯ä¸ª GPU å¯¹åº”ä¸€ä¸ª kfd_process_deviceï¼Œå…¶ä¸­è®°å½•äº†è¯¥è¿›ç¨‹åœ¨è¿™å— GPU ä¸Šçš„ doorbell æ˜ å°„ã€é˜Ÿåˆ—åˆ—è¡¨å’Œåœ°å€ç©ºé—´ IDï¼ˆPASIDï¼‰ã€‚',
            ],
            keyPoints: [
              'HSA å®šä¹‰ CPU/GPU ä¸ºå¹³ç­‰çš„è®¡ç®—ä»£ç†ï¼ˆAgentï¼‰ï¼Œå…±äº«è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œæ¶ˆé™¤æ˜¾å¼æ•°æ®æ‹·è´',
              'KFD ä»£ç ä½äº drivers/gpu/drm/amd/amdkfd/ï¼Œæ˜¯ amdgpu çš„å­æ¨¡å—è€Œéç‹¬ç«‹é©±åŠ¨',
              '/dev/kfd é¢å‘ HSA è®¡ç®—ï¼ˆROCm/HIPï¼‰ï¼Œ/dev/dri/renderD128 é¢å‘å›¾å½¢æ¸²æŸ“ï¼ˆMesaï¼‰',
              'KFD ä½¿ç”¨ AQL å‘½ä»¤åŒ… + Compute Queueï¼›DRM ä½¿ç”¨ PM4 å‘½ä»¤åŒ… + GFX Ring',
              'kfd_process æ˜¯ KFD çš„æ ¸å¿ƒæ•°æ®ç»“æ„ï¼Œç®¡ç†ä¸€ä¸ªè¿›ç¨‹åœ¨æ‰€æœ‰ GPU ä¸Šçš„è®¡ç®—èµ„æº',
              'kfd_process_device å…³è”è¿›ç¨‹ä¸å…·ä½“ GPUï¼ŒæŒæœ‰ PASIDã€doorbell æ˜ å°„å’Œé˜Ÿåˆ—åˆ—è¡¨',
            ],
          },
          diagram: {
            title: 'KFD ä¸ DRM åŒè·¯å¾„æ¶æ„',
            content: `amdgpu é©±åŠ¨çš„åŒæ¥å£æ¶æ„ï¼šDRMï¼ˆå›¾å½¢ï¼‰vs KFDï¼ˆè®¡ç®—ï¼‰

ç”¨æˆ·ç©ºé—´
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  å›¾å½¢è·¯å¾„                              è®¡ç®—è·¯å¾„
  â”€â”€â”€â”€â”€â”€â”€â”€                              â”€â”€â”€â”€â”€â”€â”€â”€
  æ¸¸æˆ / Blender                        HIP ç¨‹åº / PyTorch
       â”‚                                     â”‚
       â–¼                                     â–¼
  Mesa radeonsi/radv                    ROCm Runtime
  (OpenGL / Vulkan)                     libhsa-runtime64.so
       â”‚                                     â”‚
       â–¼                                     â–¼
  libdrm (amdgpu)                       ç›´æ¥ ioctl
       â”‚                                     â”‚
       â–¼                                     â–¼
  /dev/dri/renderD128                   /dev/kfd
  (DRM render node)                     (HSA device node)
       â”‚                                     â”‚
â•â•â•â•â•â•â•â•ªâ•â•â•â•â• ç³»ç»Ÿè°ƒç”¨è¾¹ç•Œ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       â”‚                                     â”‚
å†…æ ¸ç©ºé—´â”‚                                     â”‚
       â–¼                                     â–¼
  DRM ioctl åˆ†å‘                        KFD ioctl åˆ†å‘
  drm_ioctl()                           kfd_ioctl()
       â”‚                                     â”‚
       â–¼                                     â–¼
  amdgpu_cs_ioctl()                     kfd_ioctl_create_queue()
  â”œâ”€ PM4 å‘½ä»¤åŒ…éªŒè¯                     â”œâ”€ AQL é˜Ÿåˆ—åˆ›å»º
  â”œâ”€ GFX Ring æäº¤                      â”œâ”€ Compute Queue æ˜ å°„
  â””â”€ fence åŒæ­¥                         â””â”€ doorbell åˆ†é…
       â”‚                                     â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
          amdgpu ç¡¬ä»¶æŠ½è±¡å±‚
          â”œâ”€ MMIO å¯„å­˜å™¨è®¿é—®
          â”œâ”€ VRAM ç®¡ç† (TTM)
          â”œâ”€ ä¸­æ–­å¤„ç† (IH Ring)
          â””â”€ å›ºä»¶æ¥å£ (PSP/SMU)
                  â”‚
                  â–¼
            GPU ç¡¬ä»¶ (Navi33)
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚ Shader Engines (32 CU)  â”‚
            â”‚ â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”        â”‚
            â”‚ â”‚GFX  â”‚ â”‚Comp â”‚        â”‚
            â”‚ â”‚Ringsâ”‚ â”‚Queueâ”‚        â”‚
            â”‚ â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜        â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜`,
            caption: 'amdgpu é©±åŠ¨åŒæ—¶ä¸ºå›¾å½¢æ¸²æŸ“å’Œ GPU è®¡ç®—æä¾›å†…æ ¸æ¥å£ã€‚ä¸¤æ¡è·¯å¾„åœ¨ç”¨æˆ·ç©ºé—´åˆ†åˆ«é€šè¿‡ /dev/dri/renderD128 å’Œ /dev/kfd è¿›å…¥å†…æ ¸ï¼Œåœ¨åº•å±‚å…±äº«ç¡¬ä»¶è®¿é—®å±‚ã€‚Compute Queue å¯ä»¥ç‹¬ç«‹äº GFX Ring è¢« GPU ç›´æ¥è°ƒåº¦ã€‚',
          },
          codeWalk: {
            title: 'kfd_open â€” è¿›ç¨‹é¦–æ¬¡æ‰“å¼€ /dev/kfd çš„å…¥å£',
            file: 'drivers/gpu/drm/amd/amdkfd/kfd_chardev.c',
            language: 'c',
            code: `/* kfd_chardev.c â€” /dev/kfd çš„æ–‡ä»¶æ“ä½œå®ç° */

static const struct file_operations kfd_fops = {
    .owner   = THIS_MODULE,
    .unlocked_ioctl = kfd_ioctl,  /* æ‰€æœ‰ KFD ioctl çš„å…¥å£ */
    .compat_ioctl   = compat_ptr_ioctl,
    .open    = kfd_open,           /* è¿›ç¨‹æ‰“å¼€ /dev/kfd */
    .release = kfd_release,        /* è¿›ç¨‹å…³é—­ /dev/kfd */
    .mmap    = kfd_mmap,           /* mmap doorbell / events */
};

static int kfd_open(struct inode *inode, struct file *filep)
{
    struct kfd_process *process;
    bool is_32bit_user_mode;

    /* æ£€æŸ¥å½“å‰è¿›ç¨‹æ˜¯å¦æ˜¯ 32 ä½â€”â€”KFD ä¸æ”¯æŒ 32 ä½è¿›ç¨‹ */
    is_32bit_user_mode = in_compat_syscall();
    if (is_32bit_user_mode) {
        dev_warn(kfd_device,
            "Process %d (32-bit) rejected\\n", current->pid);
        return -EPERM;
    }

    /* æ ¸å¿ƒï¼šè·å–æˆ–åˆ›å»ºå½“å‰è¿›ç¨‹çš„ kfd_process
     * å¦‚æœè¿›ç¨‹å·²ç»æ‰“å¼€è¿‡ /dev/kfdï¼Œè¿”å›å·²æœ‰çš„ kfd_process
     * å¦åˆ™åˆ›å»ºæ–°çš„ kfd_process å¹¶åˆå§‹åŒ–ï¼š
     *   - åˆ†é… PASID (Process Address Space ID)
     *   - ä¸ºæ¯ä¸ª GPU åˆ›å»º kfd_process_device
     *   - æ³¨å†Œ MMU notifierï¼ˆç›‘æ§è¿›ç¨‹é¡µè¡¨å˜åŒ–ï¼‰
     */
    process = kfd_create_process(current);
    if (IS_ERR(process))
        return PTR_ERR(process);

    /* å°† kfd_process ä¿å­˜åˆ° file çš„ private_data
     * åç»­æ‰€æœ‰ ioctl è°ƒç”¨éƒ½é€šè¿‡å®ƒè·å–è¿›ç¨‹ä¸Šä¸‹æ–‡
     */
    if (kfd_is_locked()) {
        kfd_unref_process(process);
        return -EAGAIN;
    }

    /* kfd_process å¼•ç”¨è®¡æ•° +1 */
    filep->private_data = process;

    dev_dbg(kfd_device, "Opened /dev/kfd for pid %d\\n",
            process->lead_thread->pid);
    return 0;
}`,
            annotations: [
              'kfd_fops æ˜¯ /dev/kfd è®¾å¤‡èŠ‚ç‚¹çš„æ–‡ä»¶æ“ä½œè¡¨ï¼Œkfd_ioctl å¤„ç†æ‰€æœ‰ HSA ioctl è¯·æ±‚',
              'KFD ä¸æ”¯æŒ 32 ä½è¿›ç¨‹â€”â€”HSA è¦æ±‚ 64 ä½è™šæ‹Ÿåœ°å€ç©ºé—´ä»¥å®ç° CPU-GPU ç»Ÿä¸€å¯»å€',
              'kfd_create_process() æ˜¯æ ¸å¿ƒå‡½æ•°ï¼šåˆ†é… PASIDã€åˆ›å»º kfd_process_deviceã€æ³¨å†Œ MMU notifier',
              'PASID æ˜¯è¿›ç¨‹åœ°å€ç©ºé—´ IDï¼ŒGPU ç”¨å®ƒæ¥åŒºåˆ†ä¸åŒè¿›ç¨‹çš„é¡µè¡¨ï¼Œå®ç°è¿›ç¨‹éš”ç¦»',
              'MMU notifier è®© KFD æ„ŸçŸ¥è¿›ç¨‹é¡µè¡¨å˜åŒ–ï¼ˆå¦‚ munmapï¼‰ï¼ŒåŠæ—¶æ›´æ–° GPU é¡µè¡¨ä¿æŒä¸€è‡´',
              'filep->private_data ä¿å­˜ kfd_process æŒ‡é’ˆï¼Œåç»­ ioctl é€šè¿‡å®ƒæ‰¾åˆ°è¿›ç¨‹çš„ GPU èµ„æº',
            ],
            explanation: 'è¿™æ®µä»£ç æ˜¯ç”¨æˆ·ç©ºé—´ ROCm è¿è¡Œæ—¶è®¿é—® GPU è®¡ç®—èƒ½åŠ›çš„ç¬¬ä¸€æ­¥ã€‚å½“ libhsa-runtime64.so è°ƒç”¨ open("/dev/kfd", ...) æ—¶ï¼Œå†…æ ¸æ‰§è¡Œ kfd_openï¼Œä¸ºè¯¥è¿›ç¨‹åˆ›å»ºå®Œæ•´çš„ HSA æ‰§è¡Œç¯å¢ƒã€‚kfd_create_process å†…éƒ¨ä¼šéå†ç³»ç»Ÿä¸­æ‰€æœ‰ KFD è®¾å¤‡ï¼ˆGPUï¼‰ï¼Œä¸ºæ¯ä¸ª GPU åˆ›å»º kfd_process_deviceï¼Œè¿™æ„å‘³ç€ä¸€ä¸ª ROCm è¿›ç¨‹ä»ä¸€å¼€å§‹å°±èƒ½è®¿é—®æ‰€æœ‰å·²æ³¨å†Œçš„ GPUã€‚ç†è§£è¿™ä¸ªå…¥å£ç‚¹æ˜¯é˜…è¯»æ‰€æœ‰ KFD ä»£ç çš„èµ·ç‚¹ã€‚',
          },
          miniLab: {
            title: 'æ¢ç´¢ /dev/kfd è®¾å¤‡èŠ‚ç‚¹å’Œ KFD æºç ç»“æ„',
            objective: 'æ£€æŸ¥ç³»ç»Ÿä¸Šçš„ KFD è®¾å¤‡èŠ‚ç‚¹ã€å†…æ ¸æ¨¡å—å‚æ•°ï¼Œå¹¶äº†è§£ KFD æºç ç›®å½•ç»“æ„ã€‚',
            steps: [
              'æ£€æŸ¥ /dev/kfd æ˜¯å¦å­˜åœ¨ï¼šls -la /dev/kfdï¼ˆéœ€è¦ amdgpu å†…æ ¸æ¨¡å—å’Œ ROCm æ”¯æŒï¼‰',
              'æŸ¥çœ‹ KFD åœ¨ dmesg ä¸­çš„åˆå§‹åŒ–ä¿¡æ¯ï¼šdmesg | grep -i "kfd\\|hsa"',
              'å¦‚æœå®‰è£…äº† ROCmï¼šè¿è¡Œ /opt/rocm/bin/rocminfo æŸ¥çœ‹ HSA Agent åˆ—è¡¨',
              'ç»Ÿè®¡ KFD æºç è§„æ¨¡ï¼šfind drivers/gpu/drm/amd/amdkfd/ -name "*.c" -o -name "*.h" | xargs wc -l | tail -1',
              'æŸ¥çœ‹ KFD ioctl å®šä¹‰ï¼šgrep -n "AMDKFD_IOC_" include/uapi/linux/kfd_ioctl.h | head -20',
              'æ£€æŸ¥å†…æ ¸æ˜¯å¦å¯ç”¨äº† KFDï¼šzgrep HSA_AMD /proc/config.gz æˆ– grep HSA_AMD /boot/config-$(uname -r)',
            ],
            expectedOutput: `$ ls -la /dev/kfd
crw-rw---- 1 root render 234, 0  /dev/kfd   â† major 234 å­—ç¬¦è®¾å¤‡

$ dmesg | grep -i kfd
[  2.65] kfd kfd: Initialized module
[  2.66] kfd kfd: added device 1002:7480   â† ä½ çš„ Navi33

$ rocminfo | grep -A2 "Agent"
Agent 1: CPU (gfx000)
Agent 2: GPU (gfx1102)          â† ä½ çš„ GPU ä½œä¸º HSA Agent

$ grep HSA_AMD /boot/config-$(uname -r)
CONFIG_HSA_AMD=y                â† KFD å·²ç¼–è¯‘è¿›å†…æ ¸`,
            hint: 'å¦‚æœ /dev/kfd ä¸å­˜åœ¨ï¼Œæ£€æŸ¥å†…æ ¸é…ç½®ä¸­ CONFIG_HSA_AMD æ˜¯å¦å¯ç”¨ã€‚å¦‚æœä½¿ç”¨å‘è¡Œç‰ˆå†…æ ¸ï¼Œå¤§å¤šæ•°ç°ä»£å‘è¡Œç‰ˆé»˜è®¤å¯ç”¨æ­¤é€‰é¡¹ã€‚ROCm å®‰è£…ä¸æ˜¯å¿…é¡»çš„â€”â€”/dev/kfd ç”±å†…æ ¸ amdgpu æ¨¡å—åˆ›å»ºã€‚',
          },
          debugExercise: {
            title: 'è¯Šæ–­ KFD è®¾å¤‡æ‰“å¼€å¤±è´¥',
            language: 'c',
            description: 'ä¸€ä¸ª ROCm åº”ç”¨åœ¨è°ƒç”¨ open("/dev/kfd", O_RDWR) æ—¶è¿”å›é”™è¯¯ã€‚ä»¥ä¸‹æ˜¯ç›¸å…³çš„ strace è¾“å‡ºå’Œ dmesg æ—¥å¿—ã€‚æ‰¾å‡ºå¤±è´¥åŸå› ã€‚',
            question: 'ä¸ºä»€ä¹ˆè¿›ç¨‹æ— æ³•æ‰“å¼€ /dev/kfdï¼Ÿç»™å‡ºæ ¹æœ¬åŸå› å’Œè§£å†³æ–¹æ³•ã€‚',
            buggyCode: `/* strace è¾“å‡º */
openat(AT_FDCWD, "/dev/kfd", O_RDWR) = -1 EACCES (Permission denied)

/* dmesg æ—¥å¿— */
[  2.65] kfd kfd: Initialized module
[  2.66] kfd kfd: added device 1002:7480

/* è®¾å¤‡èŠ‚ç‚¹æƒé™ */
$ ls -la /dev/kfd
crw-rw---- 1 root render 234, 0 /dev/kfd

/* å½“å‰ç”¨æˆ·çš„ç»„ */
$ groups
myuser adm sudo audio

/* å¦ä¸€ç§å¯èƒ½çš„å¤±è´¥åœºæ™¯ */
$ /opt/rocm/bin/rocminfo
HSA_STATUS_ERROR_OUT_OF_RESOURCES: PASID allocation failed`,
            hint: 'ç¬¬ä¸€ä¸ªåœºæ™¯ï¼šæ£€æŸ¥ç”¨æˆ·æ˜¯å¦å±äº render ç»„ã€‚ç¬¬äºŒä¸ªåœºæ™¯ï¼šPASID åˆ†é…å¤±è´¥é€šå¸¸ä¸ IOMMU é…ç½®æœ‰å…³ã€‚',
            answer: 'åœºæ™¯ 1ï¼ˆEACCESï¼‰ï¼š/dev/kfd çš„æƒé™æ˜¯ crw-rw---- root:renderï¼Œåªæœ‰ root å’Œ render ç»„çš„ç”¨æˆ·å¯ä»¥æ‰“å¼€ã€‚å½“å‰ç”¨æˆ·ä¸åœ¨ render ç»„ä¸­ã€‚è§£å†³ï¼šsudo usermod -aG render myuserï¼Œç„¶åé‡æ–°ç™»å½•ã€‚åœºæ™¯ 2ï¼ˆPASID åˆ†é…å¤±è´¥ï¼‰ï¼šPASIDï¼ˆProcess Address Space IDï¼‰ç”± IOMMU å­ç³»ç»Ÿç®¡ç†ã€‚å¦‚æœå†…æ ¸å¯åŠ¨æ—¶æœªå¯ç”¨ IOMMUï¼ˆç¼ºå°‘ iommu=on æˆ– amd_iommu=on å†…æ ¸å‚æ•°ï¼‰ï¼ŒKFD å¯èƒ½æ— æ³•åˆ†é… PASIDã€‚è§£å†³ï¼šåœ¨ GRUB é…ç½®ä¸­æ·»åŠ  amd_iommu=on iommu=pt å†…æ ¸å‚æ•°ï¼Œé‡æ–°å¯åŠ¨ã€‚iommu=ptï¼ˆpassthroughï¼‰æ¨¡å¼å…è®¸ KFD ä½¿ç”¨ IOMMU è¿›è¡Œ PASID ç®¡ç†è€Œä¸å½±å“ DMA æ€§èƒ½ã€‚è¿™ä¸¤ä¸ªéƒ½æ˜¯éƒ¨ç½² ROCm æ—¶æœ€å¸¸è§çš„é—®é¢˜ã€‚',
          },
          interviewQ: {
            question: 'è§£é‡Š KFD åœ¨ amdgpu é©±åŠ¨ä¸­çš„è§’è‰²ã€‚å®ƒä¸ä¼ ç»Ÿçš„ DRM æ¸²æŸ“æ¥å£æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿä¸ºä»€ä¹ˆéœ€è¦ä¸¤ä¸ªç‹¬ç«‹çš„æ¥å£ï¼Ÿ',
            difficulty: 'medium',
            hint: 'ä»è®¾è®¡ç›®æ ‡ï¼ˆå›¾å½¢ vs è®¡ç®—ï¼‰ã€å‘½ä»¤æ ¼å¼ï¼ˆPM4 vs AQLï¼‰ã€é˜Ÿåˆ—æ¨¡å‹ï¼ˆå†…æ ¸è°ƒåº¦ vs ç”¨æˆ·æ€è°ƒåº¦ï¼‰å’Œå†…å­˜æ¨¡å‹ï¼ˆGEM/TTM vs SVMï¼‰å››ä¸ªç»´åº¦å¯¹æ¯”ã€‚',
            answer: 'KFDï¼ˆKernel Fusion Driverï¼‰æ˜¯ amdgpu é©±åŠ¨ä¸­å®ç° HSA è®¡ç®—æ¥å£çš„å­æ¨¡å—ï¼Œé€šè¿‡ /dev/kfd å‘ ROCm è¿è¡Œæ—¶æš´éœ² GPU è®¡ç®—èƒ½åŠ›ã€‚å®ƒä¸ DRM æ¸²æŸ“æ¥å£çš„æ ¸å¿ƒåŒºåˆ«ï¼šï¼ˆ1ï¼‰è®¾è®¡ç›®æ ‡ï¼šDRM é¢å‘å›¾å½¢æ¸²æŸ“ï¼ˆMesa çš„ OpenGL/Vulkanï¼‰ï¼ŒKFD é¢å‘é€šç”¨è®¡ç®—ï¼ˆROCm çš„ HIP/OpenCLï¼‰ï¼›ï¼ˆ2ï¼‰å‘½ä»¤æ ¼å¼ï¼šDRM ä½¿ç”¨ PM4 å‘½ä»¤åŒ…ï¼ˆGPU å‘½ä»¤å¤„ç†å™¨åŸç”Ÿæ ¼å¼ï¼‰ï¼ŒKFD ä½¿ç”¨ AQLï¼ˆArchitected Queuing Languageï¼‰åŒ…ï¼ˆHSA æ ‡å‡†å®šä¹‰çš„å¹³å°æ— å…³æ ¼å¼ï¼‰ï¼›ï¼ˆ3ï¼‰é˜Ÿåˆ—æ¨¡å‹ï¼šDRM çš„å‘½ä»¤æäº¤éœ€è¦ç»è¿‡å†…æ ¸éªŒè¯ï¼ˆamdgpu_cs_ioctlï¼‰ï¼ŒKFD å…è®¸ç”¨æˆ·ç©ºé—´ç›´æ¥å†™å…¥é˜Ÿåˆ—å¹¶é€šè¿‡ doorbell é€šçŸ¥ GPUï¼Œç»•è¿‡å†…æ ¸çƒ­è·¯å¾„ï¼ˆå‡å°‘å»¶è¿Ÿï¼‰ï¼›ï¼ˆ4ï¼‰å†…å­˜æ¨¡å‹ï¼šDRM ä½¿ç”¨ GEM/TTM æ˜¾å¼ç®¡ç† GPU å†…å­˜ï¼ŒKFD è¿˜é¢å¤–æ”¯æŒ SVMï¼ˆShared Virtual Memoryï¼‰ï¼ŒCPU å’Œ GPU å…±äº«åŒä¸€è™šæ‹Ÿåœ°å€ç©ºé—´ã€‚éœ€è¦ä¸¤ä¸ªæ¥å£çš„åŸå› æ˜¯è®¡ç®—å·¥ä½œè´Ÿè½½æœ‰ä¸åŒçš„æ€§èƒ½è¦æ±‚â€”â€”GPU è®¡ç®—éœ€è¦æä½å»¶è¿Ÿçš„é˜Ÿåˆ—æäº¤å’Œç»Ÿä¸€å†…å­˜è®¿é—®ï¼Œè¿™äº›åœ¨ä¼ ç»Ÿå›¾å½¢ API ä¸­ä¸æ˜¯ä¼˜å…ˆè€ƒè™‘çš„ã€‚',
            amdContext: 'è¿™æ˜¯ AMD ROCm å›¢é˜Ÿé¢è¯•çš„ç»å…¸é—®é¢˜ã€‚å…³é”®æ˜¯å±•ç¤ºä½ ç†è§£ KFD ä¸æ˜¯ DRM çš„æ›¿ä»£å“ï¼Œè€Œæ˜¯é’ˆå¯¹è®¡ç®—åœºæ™¯çš„ä¸“ç”¨æ¥å£ï¼Œä¸¤è€…åœ¨åº•å±‚å…±äº« amdgpu çš„ç¡¬ä»¶æŠ½è±¡å±‚ã€‚',
          },
        },

        // â”€â”€ Lesson 7.1.2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        {
          id: '7-1-2',
          number: '7.1.2',
          title: 'KFD é˜Ÿåˆ—ç®¡ç†ä¸ AQL å‘½ä»¤åŒ…',
          titleEn: 'KFD Queue Management & AQL Packets',
          duration: 20,
          difficulty: 'advanced',
          tags: ['AQL', 'compute-queue', 'HQD', 'MQD', 'doorbell', 'user-mode-queue'],
          concept: {
            summary: 'è®¡ç®—é˜Ÿåˆ—æ˜¯ KFD çš„æ ¸å¿ƒæŠ½è±¡ã€‚ä¸å›¾å½¢ Ring Buffer ä¸åŒï¼ŒKFD çš„è®¡ç®—é˜Ÿåˆ—å…è®¸ç”¨æˆ·ç©ºé—´ç›´æ¥å†™å…¥ AQL å‘½ä»¤åŒ…å¹¶é€šè¿‡ doorbell å¯„å­˜å™¨é€šçŸ¥ GPU æ‰§è¡Œï¼Œæ— éœ€å†…æ ¸å‚ä¸çƒ­è·¯å¾„ã€‚HQDï¼ˆHardware Queue Descriptorï¼‰å’Œ MQDï¼ˆMemory Queue Descriptorï¼‰æ˜¯å°†è½¯ä»¶é˜Ÿåˆ—æ˜ å°„åˆ° GPU ç¡¬ä»¶çš„å…³é”®æ•°æ®ç»“æ„ã€‚',
            explanation: [
              'åœ¨ä¼ ç»Ÿçš„å›¾å½¢æ¸²æŸ“è·¯å¾„ä¸­ï¼Œæ¯æ¬¡æäº¤å‘½ä»¤éƒ½è¦é€šè¿‡å†…æ ¸ï¼ˆioctl â†’ amdgpu_cs_ioctl â†’ éªŒè¯ â†’ å†™å…¥ Ring Bufferï¼‰ï¼Œè¿™å¼•å…¥äº†ç³»ç»Ÿè°ƒç”¨å¼€é”€ã€‚å¯¹äºé«˜ååé‡çš„ GPU è®¡ç®—åœºæ™¯ï¼ˆå¦‚ AI è®­ç»ƒä¸­æ¯ç§’æ•°åƒæ¬¡ kernel launchï¼‰ï¼Œè¿™ä¸ªå¼€é”€ä¸å¯æ¥å—ã€‚KFD çš„è§£å†³æ–¹æ¡ˆæ˜¯ç”¨æˆ·æ€é˜Ÿåˆ—ï¼ˆUser-Mode Queueï¼‰ï¼šé˜Ÿåˆ—çš„å†…å­˜ç›´æ¥æ˜ å°„åˆ°ç”¨æˆ·ç©ºé—´ï¼Œç”¨æˆ·ç©ºé—´å¯ä»¥ç›´æ¥å†™å…¥ AQL åŒ…ï¼Œç„¶åå†™ doorbell å¯„å­˜å™¨é€šçŸ¥ GPUï¼Œæ•´ä¸ªè¿‡ç¨‹ä¸éœ€è¦ç³»ç»Ÿè°ƒç”¨ã€‚',
              'AQLï¼ˆArchitected Queuing Languageï¼‰æ˜¯ HSA æ ‡å‡†å®šä¹‰çš„å‘½ä»¤åŒ…æ ¼å¼ã€‚æ¯ä¸ª AQL åŒ…æ˜¯å›ºå®šçš„ 64 å­—èŠ‚ï¼ŒåŒ…å«ï¼šç±»å‹ï¼ˆKernel Dispatchã€Barrierã€Agent Dispatchï¼‰ã€ç»´åº¦ä¿¡æ¯ï¼ˆgrid_size_x/y/zã€workgroup_size_x/y/zï¼‰ã€å†…æ ¸ä»£ç å…¥å£åœ°å€ï¼ˆkernel_objectï¼‰ã€å†…æ ¸å‚æ•°åœ°å€ï¼ˆkernarg_addressï¼‰ã€å®Œæˆä¿¡å·ï¼ˆcompletion_signalï¼‰ã€‚ä¸ PM4 æ ¼å¼çš„å…³é”®åŒºåˆ«æ˜¯ï¼šAQL æ˜¯ HSA æ ‡å‡†åŒ–çš„ï¼Œè·¨å¹³å°å¯ç§»æ¤ï¼›PM4 æ˜¯ AMD GPU ç¡¬ä»¶ç§æœ‰çš„ï¼Œæ€§èƒ½å¯èƒ½æ›´é«˜ä½†ä¸å¯ç§»æ¤ã€‚',
              'HQDï¼ˆHardware Queue Descriptorï¼‰æ˜¯ GPU ç¡¬ä»¶ä¸­å›ºå®šæ•°é‡çš„é˜Ÿåˆ—æ§½ä½ï¼Œæ¯ä¸ª HQD å¯¹åº”ä¸€ä¸ªç¡¬ä»¶å¯ä»¥ç›´æ¥è°ƒåº¦çš„é˜Ÿåˆ—ã€‚Navi33 çš„æ¯ä¸ª Compute Engine æœ‰å¤šä¸ª HQDï¼Œæ€»æ•°æœ‰é™ã€‚MQDï¼ˆMemory Queue Descriptorï¼‰æ˜¯ KFD åœ¨å†…å­˜ä¸­åˆ›å»ºçš„é˜Ÿåˆ—æè¿°æ•°æ®ç»“æ„ï¼ŒåŒ…å«é˜Ÿåˆ—çš„æ‰€æœ‰çŠ¶æ€ï¼šåŸºåœ°å€ã€å¤§å°ã€è¯»å†™æŒ‡é’ˆã€doorbell offset ç­‰ã€‚å½“é˜Ÿåˆ—è¢«æ˜ å°„åˆ° HQD æ—¶ï¼ŒGPU çš„ CPï¼ˆCommand Processorï¼‰ä» MQD ä¸­åŠ è½½é˜Ÿåˆ—å‚æ•°ï¼›å½“é˜Ÿåˆ—è¢«æŠ¢å ï¼ˆpreemptï¼‰æ—¶ï¼ŒCP å°†å½“å‰çŠ¶æ€ä¿å­˜å› MQDã€‚è¿™ç§ MQD-HQD æ˜ å°„æœºåˆ¶å…è®¸è½¯ä»¶é˜Ÿåˆ—æ•°é‡è¿œè¶…ç¡¬ä»¶ HQD æ•°é‡â€”â€”é€šè¿‡é˜Ÿåˆ—è°ƒåº¦å™¨ï¼ˆHWS, Hardware Scheduler æˆ– SWS, Software Schedulerï¼‰åŠ¨æ€æ˜ å°„ã€‚',
              'ç”¨æˆ·æ€é˜Ÿåˆ—æäº¤çš„å®Œæ•´æµç¨‹ï¼šï¼ˆ1ï¼‰ç”¨æˆ·ç©ºé—´åœ¨é˜Ÿåˆ—å†…å­˜ä¸­å†™å…¥ AQL åŒ…ï¼›ï¼ˆ2ï¼‰æ›´æ–°é˜Ÿåˆ—çš„ write_dispatch_idï¼ˆå†™æŒ‡é’ˆï¼‰ï¼›ï¼ˆ3ï¼‰å†™ doorbell å¯„å­˜å™¨â€”â€”è¿™æ˜¯ä¸€ä¸ªå†…å­˜æ˜ å°„çš„ MMIO åœ°å€ï¼Œä¸€æ¬¡ 4 å­—èŠ‚å†™å…¥å°±èƒ½é€šçŸ¥ GPU çš„ CP æœ‰æ–°å‘½ä»¤ï¼›ï¼ˆ4ï¼‰GPU çš„ CP æ£€æµ‹åˆ° doorbell å†™å…¥ï¼Œä»å¯¹åº”é˜Ÿåˆ—çš„ MQD ä¸­è·å–è¯»æŒ‡é’ˆï¼Œè¯»å– AQL åŒ…ï¼›ï¼ˆ5ï¼‰CP è§£æ AQL åŒ…ï¼Œå¯åŠ¨è®¡ç®—ç€è‰²å™¨ï¼ˆdispatchï¼‰ï¼›ï¼ˆ6ï¼‰è®¡ç®—å®Œæˆåï¼ŒGPU æ›´æ–°å®Œæˆä¿¡å·ï¼ˆcompletion_signalï¼‰ã€‚æ•´ä¸ªçƒ­è·¯å¾„â€”â€”ä»å†™ AQL åŒ…åˆ° GPU å¼€å§‹æ‰§è¡Œâ€”â€”åªéœ€è¦ç”¨æˆ·ç©ºé—´çš„å†…å­˜å†™æ“ä½œå’Œä¸€æ¬¡ doorbell MMIO å†™å…¥ï¼Œå»¶è¿Ÿåœ¨å¾®ç§’çº§ã€‚',
            ],
            keyPoints: [
              'ç”¨æˆ·æ€é˜Ÿåˆ—å…è®¸ç›´æ¥å†™å…¥ AQL åŒ… + doorbell MMIOï¼Œç»•è¿‡å†…æ ¸çƒ­è·¯å¾„ï¼Œå»¶è¿Ÿåœ¨å¾®ç§’çº§',
              'AQL åŒ…å›ºå®š 64 å­—èŠ‚ï¼ŒåŒ…å« dispatch ç»´åº¦ã€kernel_object åœ°å€ã€kernarg åœ°å€å’Œ completion_signal',
              'HQD æ˜¯ GPU ç¡¬ä»¶é˜Ÿåˆ—æ§½ä½ï¼ˆæ•°é‡æœ‰é™ï¼‰ï¼ŒMQD æ˜¯å†…å­˜ä¸­çš„é˜Ÿåˆ—æè¿°ç¬¦ï¼ˆå¯ä»¥å¾ˆå¤šï¼‰',
              'MQD â†” HQD åŠ¨æ€æ˜ å°„ç”± HWSï¼ˆHardware Schedulerï¼‰æˆ– KFD è½¯ä»¶è°ƒåº¦å™¨ç®¡ç†',
              'doorbell æ˜¯ä¸€ä¸ª 4 å­—èŠ‚ MMIO å†™å…¥ï¼ŒGPU CP æ£€æµ‹åˆ°åä»å¯¹åº”é˜Ÿåˆ—è¯»å–æ–°å‘½ä»¤',
              'é˜Ÿåˆ—æŠ¢å ï¼šCP å°†å½“å‰çŠ¶æ€ä¿å­˜å› MQDï¼Œé‡Šæ”¾ HQD ç»™å…¶ä»–é˜Ÿåˆ—ä½¿ç”¨',
            ],
          },
          diagram: {
            title: 'AQL ç”¨æˆ·æ€é˜Ÿåˆ—æäº¤æµç¨‹',
            content: `ç”¨æˆ·æ€ AQL é˜Ÿåˆ—æäº¤è·¯å¾„ï¼ˆé›¶å†…æ ¸ä»‹å…¥ï¼‰

ç”¨æˆ·ç©ºé—´ (ROCm Runtime)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  1) å†™å…¥ AQL åŒ…åˆ°é˜Ÿåˆ—å†…å­˜
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  AQL Queue (mmap'd to userspace)             â”‚
  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
  â”‚  â”‚AQL pkt â”‚AQL pkt â”‚AQL pkt â”‚ (ç©º)   â”‚       â”‚
  â”‚  â”‚dispatchâ”‚dispatchâ”‚barrier â”‚        â”‚       â”‚
  â”‚  â”‚grid:   â”‚grid:   â”‚signal  â”‚        â”‚       â”‚
  â”‚  â”‚256x1x1 â”‚1024x1  â”‚wait    â”‚        â”‚       â”‚
  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
  â”‚   read_ptr â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²  â–²â”€â”€ write_ptr    â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚  â”‚
  2) æ›´æ–° write_dispatch_id  â”‚  â”‚
  3) å†™ doorbell å¯„å­˜å™¨ â”€â”€â”€â”€â”€â”¼â”€â”€â”˜
     *(uint32_t*)doorbell_mmap = new_wptr;
                             â”‚
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• æ— ç³»ç»Ÿè°ƒç”¨ â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                             â”‚
GPU ç¡¬ä»¶                     â”‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  4) Command Processor æ£€æµ‹ doorbell å†™å…¥
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚    CP (MEC/HPD)       â”‚
     â”‚    æ£€æµ‹ doorbell      â”‚â”€â”€â†’ è¯»å– MQD
     â”‚    doorbell[queue_id] â”‚      â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â–¼
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚   MQD    â”‚
                              â”‚ base_addrâ”‚
                              â”‚ read_ptr â”‚
                              â”‚ write_ptrâ”‚
                              â”‚ doorbell â”‚
                              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                                   â”‚
  5) ä»é˜Ÿåˆ—å†…å­˜è¯»å– AQL åŒ…         â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”
     â”‚  AQL Packet (64 bytes)         â”‚
     â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
     â”‚  â”‚ header:    DISPATCH       â”‚ â”‚
     â”‚  â”‚ dimensions: 3             â”‚ â”‚
     â”‚  â”‚ grid_size_x: 256         â”‚ â”‚
     â”‚  â”‚ workgroup_size_x: 64     â”‚ â”‚
     â”‚  â”‚ kernel_object: 0x7f...   â”‚ â”‚
     â”‚  â”‚ kernarg_address: 0x7f... â”‚ â”‚
     â”‚  â”‚ completion_signal: sig_1 â”‚ â”‚
     â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
  6) å¯åŠ¨ Compute Shader
     Shader Engines æ‰§è¡Œ kernel
     å®Œæˆåæ›´æ–° completion_signal`,
            caption: 'ç”¨æˆ·æ€ AQL é˜Ÿåˆ—çš„æäº¤æµç¨‹ã€‚æ•´ä¸ªçƒ­è·¯å¾„ä¸æ¶‰åŠç³»ç»Ÿè°ƒç”¨ï¼šç”¨æˆ·ç©ºé—´ç›´æ¥åœ¨ mmap çš„é˜Ÿåˆ—å†…å­˜ä¸­å†™å…¥ AQL åŒ…ï¼Œç„¶åå†™ doorbell MMIO é€šçŸ¥ GPUã€‚GPU çš„ Command Processorï¼ˆMECï¼‰æ£€æµ‹åˆ° doorbell åè¯»å–å¹¶æ‰§è¡Œå‘½ä»¤ã€‚',
          },
          codeWalk: {
            title: 'kfd_ioctl_create_queue â€” åˆ›å»ºè®¡ç®—é˜Ÿåˆ—',
            file: 'drivers/gpu/drm/amd/amdkfd/kfd_chardev.c',
            language: 'c',
            code: `/* kfd_chardev.c â€” åˆ›å»º KFD è®¡ç®—é˜Ÿåˆ—çš„ ioctl å¤„ç†å‡½æ•° */

static int kfd_ioctl_create_queue(struct file *filep,
                struct kfd_process *p, void *data)
{
    struct kfd_ioctl_create_queue_args *args = data;
    struct kfd_dev *dev;
    struct kfd_process_device *pdd;
    struct queue_properties properties;
    int err;

    /* æŸ¥æ‰¾ç›®æ ‡ GPU è®¾å¤‡ */
    dev = kfd_device_by_id(args->gpu_id);
    if (!dev)
        return -EINVAL;

    /* è·å–è¿›ç¨‹åœ¨è¯¥ GPU ä¸Šçš„ process_device */
    pdd = kfd_get_process_device_data(dev, p);
    if (!pdd)
        return -ENOMEM;

    /* å°†ç”¨æˆ·ç©ºé—´å‚æ•°è½¬æ¢ä¸ºå†…æ ¸ queue_properties
     * åŒ…æ‹¬ï¼šé˜Ÿåˆ—ç±»å‹ã€é˜Ÿåˆ—å¤§å°ã€ä¼˜å…ˆçº§
     *       ring_base_addressï¼ˆé˜Ÿåˆ—å†…å­˜åŸºåœ°å€ï¼Œç”¨æˆ·æ€åˆ†é…ï¼‰
     *       write_ptr / read_ptr åœ°å€
     *       doorbell_offset
     */
    memset(&properties, 0, sizeof(properties));
    properties.type = args->queue_type;
    properties.queue_address = args->ring_base_address;
    properties.queue_size = args->ring_size;
    properties.queue_percent = args->queue_percentage;
    properties.priority = args->queue_priority;

    /* åˆ†é… doorbell é¡µé¢å¹¶è®¾ç½®åç§» */
    err = kfd_queue_acquire_buffers(pdd, &properties);
    if (err)
        return err;

    /* æ ¸å¿ƒï¼šåˆ›å»ºé˜Ÿåˆ—å¹¶æ˜ å°„åˆ° GPU ç¡¬ä»¶
     * 1. åˆ†é… MQDï¼ˆMemory Queue Descriptorï¼‰
     * 2. åˆå§‹åŒ– MQD ä¸­çš„é˜Ÿåˆ—å‚æ•°
     * 3. é€šè¿‡ HWS æˆ–ç›´æ¥å†™ HQD å¯„å­˜å™¨å°†é˜Ÿåˆ—æ¿€æ´»
     */
    err = pqm_create_queue(&p->pqm, dev, filep, &properties,
                           &args->queue_id,
                           NULL, NULL, NULL, &args->doorbell_offset);
    if (err)
        goto err_create;

    /* è¿”å›ç»™ç”¨æˆ·ç©ºé—´ï¼š
     * args->queue_id     â€” é˜Ÿåˆ— IDï¼ˆåç»­æ“ä½œå¼•ç”¨ï¼‰
     * args->doorbell_offset â€” doorbell åœ¨ mmap åŒºåŸŸä¸­çš„åç§»
     *   ç”¨æˆ·ç©ºé—´ mmap /dev/kfd çš„ doorbell é¡µå
     *   å¯¹ (mmap_base + doorbell_offset) åš 32 ä½å†™å…¥å³å¯è§¦å‘ GPU
     */
    return 0;

err_create:
    kfd_queue_release_buffers(pdd, &properties);
    return err;
}`,
            annotations: [
              'args->ring_base_address æ˜¯ç”¨æˆ·ç©ºé—´é¢„å…ˆåˆ†é…çš„é˜Ÿåˆ—ç¯å½¢ç¼“å†²åŒºåœ°å€â€”â€”AQL åŒ…ç›´æ¥å†™å…¥è¿™é‡Œ',
              'kfd_queue_acquire_buffers åˆ†é… doorbell é¡µé¢â€”â€”doorbell æ˜¯ GPU MMIO ç©ºé—´çš„ä¸€å°å—åŒºåŸŸ',
              'pqm_create_queue æ˜¯æ ¸å¿ƒè°ƒç”¨é“¾ï¼šåˆ†é… MQD â†’ åˆå§‹åŒ– â†’ æ˜ å°„åˆ° HQD æˆ–åŠ å…¥è°ƒåº¦å™¨',
              'args->doorbell_offset è¿”å›ç»™ç”¨æˆ·ç©ºé—´åï¼Œç”¨æˆ·å¯ä»¥ mmap doorbell é¡µå¹¶ç›´æ¥å†™å…¥è§¦å‘ GPU',
              'queue_type å¯ä»¥æ˜¯ KFD_IOC_QUEUE_TYPE_COMPUTEï¼ˆè®¡ç®—ï¼‰æˆ– KFD_IOC_QUEUE_TYPE_SDMAï¼ˆDMAï¼‰',
              'é˜Ÿåˆ—åˆ›å»ºåï¼Œç”¨æˆ·ç©ºé—´å¯¹è¯¥é˜Ÿåˆ—çš„æ‰€æœ‰å‘½ä»¤æäº¤éƒ½ä¸éœ€è¦å†ç»è¿‡å†…æ ¸ï¼ˆé›¶ ioctl çƒ­è·¯å¾„ï¼‰',
            ],
            explanation: 'è¿™ä¸ªå‡½æ•°æ˜¯å»ºç«‹ç”¨æˆ·æ€ GPU è®¡ç®—é€šé“çš„å…³é”®æ­¥éª¤ã€‚ç”¨æˆ·ç©ºé—´é€šè¿‡æ­¤ ioctl ä¸€æ¬¡æ€§è®¾ç½®å¥½é˜Ÿåˆ—ï¼Œä¹‹åçš„æ‰€æœ‰å‘½ä»¤æäº¤ï¼ˆå†™ AQL åŒ… + å†™ doorbellï¼‰éƒ½ç›´æ¥åœ¨ç”¨æˆ·ç©ºé—´å®Œæˆã€‚pqm_create_queue å†…éƒ¨ä¼šè°ƒç”¨ GPU ç‰¹å®šçš„ MQD åˆå§‹åŒ–å‡½æ•°ï¼ˆå¦‚ gfx_v11_0 çš„ MQD åˆå§‹åŒ–ï¼‰ï¼Œè®¾ç½® HQD å¯„å­˜å™¨ï¼Œæœ€ç»ˆä½¿ GPU çš„ MECï¼ˆMicro Engine Computeï¼‰å¼€å§‹è½®è¯¢è¿™ä¸ªé˜Ÿåˆ—çš„ doorbellã€‚',
          },
          miniLab: {
            title: 'è¿½è¸ª ROCm é˜Ÿåˆ—åˆ›å»ºçš„ ioctl è°ƒç”¨',
            objective: 'ä½¿ç”¨ strace è§‚å¯Ÿ ROCm è¿è¡Œæ—¶å¦‚ä½•é€šè¿‡ /dev/kfd ioctl åˆ›å»ºè®¡ç®—é˜Ÿåˆ—å’Œæäº¤ä»»åŠ¡ã€‚',
            setup: `# éœ€è¦å®‰è£… ROCm å’Œä¸€ä¸ªç®€å•çš„ HIP ç¨‹åº
# å¦‚æœå·²å®‰è£… ROCmï¼Œå¯ä»¥ä½¿ç”¨ rocm-examples ä¸­çš„ vectorAdd
sudo apt install rocm-hip-sdk  # å¦‚æœè¿˜æ²¡å®‰è£…`,
            steps: [
              'ç¼–å†™æˆ–è·å–ä¸€ä¸ªç®€å•çš„ HIP å‘é‡åŠ æ³•ç¨‹åºï¼ˆvectorAddï¼‰',
              'ä½¿ç”¨ strace è¿½è¸ª KFD ioctlï¼šstrace -e ioctl -f ./vectorAdd 2>&1 | grep kfd',
              'æŸ¥æ‰¾ AMDKFD_IOC_CREATE_QUEUE ioctl è°ƒç”¨ï¼Œè§‚å¯Ÿé˜Ÿåˆ—åˆ›å»ºå‚æ•°',
              'æŸ¥æ‰¾ AMDKFD_IOC_ALLOC_MEMORY_OF_GPU ioctlï¼Œè§‚å¯Ÿ GPU å†…å­˜åˆ†é…',
              'ç»Ÿè®¡å„ç±» KFD ioctl çš„è°ƒç”¨æ¬¡æ•°ï¼šstrace -e ioctl -c -f ./vectorAdd 2>&1',
              'å¯¹æ¯” DRM ioctlï¼šstrace -e ioctl -f glxgears 2>&1 | head -30ï¼ˆè§‚å¯Ÿ DRM è·¯å¾„çš„å·®å¼‚ï¼‰',
            ],
            expectedOutput: `$ strace -e ioctl -f ./vectorAdd 2>&1 | grep -c CREATE_QUEUE
2        â† åˆ›å»ºäº† 2 ä¸ªè®¡ç®—é˜Ÿåˆ—ï¼ˆä¸€ä¸ª computeï¼Œä¸€ä¸ª SDMAï¼‰

$ strace -e ioctl -f ./vectorAdd 2>&1 | grep ALLOC_MEMORY
ioctl(4, AMDKFD_IOC_ALLOC_MEMORY_OF_GPU, ...)   â† åˆ†é… GPU å†…å­˜
ioctl(4, AMDKFD_IOC_ALLOC_MEMORY_OF_GPU, ...)   â† kernarg å†…å­˜

æ³¨æ„ï¼šå‘½ä»¤æäº¤ï¼ˆå†™ AQL + doorbellï¼‰ä¸ä¼šå‡ºç°åœ¨ strace ä¸­ï¼Œ
å› ä¸ºå®ƒä»¬ç›´æ¥é€šè¿‡ mmap åœ¨ç”¨æˆ·ç©ºé—´å®Œæˆï¼Œæ²¡æœ‰ç³»ç»Ÿè°ƒç”¨ï¼`,
            hint: 'å¦‚æœæ²¡æœ‰å®‰è£… ROCmï¼Œå¯ä»¥ä½¿ç”¨ ftrace ä»å†…æ ¸ä¾§è¿½è¸ª KFD å‡½æ•°è°ƒç”¨ï¼šecho kfd_ioctl_create_queue > /sys/kernel/debug/tracing/set_ftrace_filterã€‚',
          },
          debugExercise: {
            title: 'è¯Šæ–­é˜Ÿåˆ—åˆ›å»ºå¤±è´¥',
            language: 'c',
            description: 'ä¸€ä¸ª HIP ç¨‹åºåœ¨ hipLaunchKernelGGL æ—¶å´©æºƒã€‚strace æ˜¾ç¤º AMDKFD_IOC_CREATE_QUEUE è¿”å› -ENOMEMã€‚ä»¥ä¸‹æ˜¯å¯èƒ½çš„åŸå› ã€‚',
            question: 'é˜Ÿåˆ—åˆ›å»ºè¿”å› -ENOMEM çš„å¯èƒ½åŸå› æ˜¯ä»€ä¹ˆï¼Ÿå¦‚ä½•è¯Šæ–­å’Œè§£å†³ï¼Ÿ',
            buggyCode: `/* strace è¾“å‡º */
ioctl(4, AMDKFD_IOC_CREATE_QUEUE, {queue_type=COMPUTE,
    ring_size=0x400000,    /* 4MB é˜Ÿåˆ—å¤§å° */
    ring_base=0x0,         /* BUG! ç”¨æˆ·ç©ºé—´æ²¡æœ‰é¢„åˆ†é…é˜Ÿåˆ—å†…å­˜ */
    ...}) = -1 ENOMEM

/* å¦ä¸€ç§æƒ…å†µï¼šdoorbell èµ„æºè€—å°½ */
/* è¿›ç¨‹åˆ›å»ºäº†è¶…è¿‡ 1024 ä¸ªé˜Ÿåˆ—å */
ioctl(4, AMDKFD_IOC_CREATE_QUEUE, ...) = -1 ENOMEM

/* dmesg æ—¥å¿— */
[  45.2] kfd: Failed to allocate MQD for queue
[  45.2] kfd: Can't create queue: doorbell allocation failed`,
            hint: 'æœ‰ä¸¤ç§å¸¸è§åŸå› ï¼š(1) ç”¨æˆ·ç©ºé—´ä¼ å…¥äº†æ— æ•ˆçš„ ring_base_addressï¼›(2) GPU çš„ doorbell èµ„æºæˆ– MQD å†…å­˜è€—å°½ã€‚',
            answer: 'ä¸¤ç§å¸¸è§åŸå› ï¼šï¼ˆ1ï¼‰ring_base_address = 0x0ï¼šç”¨æˆ·ç©ºé—´åœ¨è°ƒç”¨ CREATE_QUEUE ioctl ä¹‹å‰å¿…é¡»å…ˆåˆ†é…é˜Ÿåˆ—ç¯å½¢ç¼“å†²åŒºå†…å­˜ï¼ˆé€šå¸¸é€šè¿‡ AMDKFD_IOC_ALLOC_MEMORY_OF_GPU åˆ†é…ï¼‰ã€‚ring_base ä¸º 0 æ„å‘³ç€ ROCm è¿è¡Œæ—¶çš„å†…å­˜åˆ†é…æ­¥éª¤å¤±è´¥äº†ï¼Œéœ€è¦æ£€æŸ¥ GPU å†…å­˜æ˜¯å¦å……è¶³ï¼ˆcat /sys/class/drm/card0/device/mem_info_vram_usedï¼‰ã€‚ï¼ˆ2ï¼‰doorbell èµ„æºè€—å°½ï¼šæ¯ä¸ªé˜Ÿåˆ—éœ€è¦ä¸€ä¸ª doorbell slotï¼ŒGPU çš„ doorbell BAR å¤§å°æœ‰é™ï¼ˆé€šå¸¸ 2MBï¼‰ï¼Œæ¯ä¸ª slot 4 å­—èŠ‚ï¼Œæœ€å¤šçº¦ 512K ä¸ª doorbellã€‚ä½†å®é™…é™åˆ¶æ›´å°â€”â€”KFD ä¸ºæ¯ä¸ªè¿›ç¨‹åˆ†é… doorbell é¡µé¢ï¼ˆ4KB/é¡µï¼‰ï¼Œæ¯é¡µå¯å®¹çº³ 1024 ä¸ª 32 ä½ doorbellã€‚å¦‚æœä¸€ä¸ªè¿›ç¨‹åˆ›å»ºäº†è¿‡å¤šé˜Ÿåˆ—ï¼Œdoorbell é¡µé¢ä¼šè€—å°½ã€‚è§£å†³æ–¹æ³•ï¼šé”€æ¯ä¸å†ä½¿ç”¨çš„é˜Ÿåˆ—ï¼ˆDESTROY_QUEUE ioctlï¼‰ï¼Œæˆ–åœ¨åº”ç”¨è®¾è®¡ä¸­å¤ç”¨é˜Ÿåˆ—ã€‚ç”Ÿäº§ç¯å¢ƒä¸­é€šå¸¸æ¯ä¸ª GPU åªéœ€è¦å‡ ä¸ªåˆ°å‡ åä¸ªé˜Ÿåˆ—ã€‚',
          },
          interviewQ: {
            question: 'è§£é‡Š AQL åŒ…å’Œ PM4 åŒ…çš„åŒºåˆ«ã€‚ä¸ºä»€ä¹ˆ KFD ä½¿ç”¨ AQL è€Œä¸æ˜¯ç›´æ¥ä½¿ç”¨ PM4ï¼Ÿç”¨æˆ·æ€é˜Ÿåˆ—ç›¸æ¯”å†…æ ¸æ€å‘½ä»¤æäº¤æœ‰ä»€ä¹ˆæ€§èƒ½ä¼˜åŠ¿ï¼Ÿ',
            difficulty: 'hard',
            hint: 'ä»æ ‡å‡†åŒ–ï¼ˆHSA vs ç¡¬ä»¶ç§æœ‰ï¼‰ã€æäº¤å»¶è¿Ÿï¼ˆç”¨æˆ·æ€ doorbell vs å†…æ ¸ ioctlï¼‰ã€å®‰å…¨æ€§ï¼ˆç”¨æˆ·æ€é˜Ÿåˆ—éš”ç¦»ï¼‰ä¸‰ä¸ªæ–¹é¢å›ç­”ã€‚',
            answer: 'AQL vs PM4ï¼šï¼ˆ1ï¼‰AQL æ˜¯ HSA æ ‡å‡†å®šä¹‰çš„æ ¼å¼ï¼ˆ64 å­—èŠ‚å›ºå®šå¤§å°ï¼‰ï¼Œè·¨å¹³å°å¯ç§»æ¤â€”â€”åŒä¸€ä¸ª AQL åŒ…ç†è®ºä¸Šå¯ä»¥åœ¨ AMD å’Œå…¶ä»– HSA å…¼å®¹ç¡¬ä»¶ä¸Šè¿è¡Œã€‚PM4 æ˜¯ AMD GPU çš„ç§æœ‰å‘½ä»¤æ ¼å¼ï¼Œç›´æ¥æ˜ å°„åˆ° CP å¾®ç æŒ‡ä»¤ï¼Œæ ¼å¼å›  GPU ä»£æ¬¡è€Œå¼‚ã€‚ï¼ˆ2ï¼‰AQL æ˜¯é¢å‘è®¡ç®—çš„â€”â€”åŒ…å« grid/workgroup ç»´åº¦ä¿¡æ¯ï¼Œé€‚åˆ kernel dispatchã€‚PM4 æ˜¯é¢å‘å›¾å½¢/é€šç”¨çš„â€”â€”åŒ…å«çŠ¶æ€è®¾ç½®ã€draw callã€DMA æ“ä½œç­‰ã€‚ï¼ˆ3ï¼‰GPU çš„ MECï¼ˆMicro Engine Computeï¼‰åŸç”Ÿæ”¯æŒè§£æ AQL åŒ…ï¼Œä¸éœ€è¦é¢å¤–çš„å‘½ä»¤è½¬æ¢ã€‚ç”¨æˆ·æ€é˜Ÿåˆ—çš„æ€§èƒ½ä¼˜åŠ¿ï¼šä¼ ç»Ÿ DRM è·¯å¾„æ¯æ¬¡æäº¤å‘½ä»¤éœ€è¦ ioctl ç³»ç»Ÿè°ƒç”¨ï¼ˆ~2Î¼s å¼€é”€ï¼‰+ å†…æ ¸æ€å‘½ä»¤éªŒè¯ + æ‹·è´åˆ° Ring Bufferã€‚KFD ç”¨æˆ·æ€é˜Ÿåˆ—åªéœ€è¦ç”¨æˆ·ç©ºé—´çš„å†…å­˜å†™å…¥ + ä¸€æ¬¡ doorbell MMIO å†™å…¥ï¼ˆ~100nsï¼‰ï¼Œå»¶è¿Ÿé™ä½ä¸€ä¸ªæ•°é‡çº§ä»¥ä¸Šã€‚å¯¹äº AI è®­ç»ƒä¸­æ¯ç§’æ•°ä¸‡æ¬¡çš„å° kernel launchï¼Œè¿™ä¸ªå·®å¼‚ç›´æ¥å½±å“ GPU åˆ©ç”¨ç‡ã€‚å®‰å…¨æ€§ï¼šæ¯ä¸ªç”¨æˆ·æ€é˜Ÿåˆ—æœ‰ç‹¬ç«‹çš„ PASID å’Œ GPUVM é¡µè¡¨ï¼ŒGPU ç¡¬ä»¶ä¿è¯è¿›ç¨‹é—´å†…å­˜éš”ç¦»ï¼Œå³ä½¿ç”¨æˆ·ç©ºé—´ç›´æ¥æ“ä½œé˜Ÿåˆ—ä¹Ÿä¸ä¼šå½±å“å…¶ä»–è¿›ç¨‹ã€‚',
            amdContext: 'AMD é¢è¯•ä¸­å¦‚æœä½ èƒ½æ¸…æ¥šè§£é‡Š AQL ç”¨æˆ·æ€é˜Ÿåˆ—çš„å»¶è¿Ÿä¼˜åŠ¿å’Œ PASID éš”ç¦»æœºåˆ¶ï¼Œè¯´æ˜ä½ ç†è§£äº† KFD è®¾è®¡çš„æ ¸å¿ƒåŠ¨æœºâ€”â€”è¿™æ¯”è®°ä½ API å‚æ•°æœ‰ç”¨å¾—å¤šã€‚',
          },
        },
      ],
    },

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Group 7.2: GPU å†…å­˜ä¸åŒæ­¥
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    {
      id: '7-2',
      number: '7.2',
      title: 'GPU å†…å­˜ä¸åŒæ­¥',
      titleEn: 'GPU Memory & Synchronization',
      icon: 'ğŸ”—',
      description: 'SVM ç»Ÿä¸€è™šæ‹Ÿåœ°å€ç©ºé—´è®© CPU å’Œ GPU å…±äº«æŒ‡é’ˆï¼ŒGPU page fault å’Œé¡µé¢è¿ç§»å®ç°æŒ‰éœ€æ•°æ®ç§»åŠ¨ã€‚HSA ä¿¡å·é‡å’Œ KFD äº‹ä»¶æœºåˆ¶å®ç°é«˜æ•ˆçš„ CPU-GPU åŒæ­¥ã€‚',
      lessons: [
        // â”€â”€ Lesson 7.2.1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        {
          id: '7-2-1',
          number: '7.2.1',
          title: 'SVM ç»Ÿä¸€è™šæ‹Ÿåœ°å€ç©ºé—´',
          titleEn: 'SVM Unified Virtual Address Space',
          duration: 20,
          difficulty: 'advanced',
          tags: ['SVM', 'GPUVM', 'PASID', 'page-fault', 'page-migration', 'coherency'],
          concept: {
            summary: 'SVMï¼ˆShared Virtual Memoryï¼‰è®© CPU å’Œ GPU å…±äº«åŒä¸€ä¸ªè™šæ‹Ÿåœ°å€ç©ºé—´â€”â€”CPU ä¸Šçš„æŒ‡é’ˆå¯ä»¥ç›´æ¥åœ¨ GPU kernel ä¸­ä½¿ç”¨ï¼Œæ— éœ€æ˜¾å¼æ‹·è´ã€‚KFD é€šè¿‡ GPUVM é¡µè¡¨ã€PASID è¿›ç¨‹éš”ç¦»å’Œ GPU page fault å¤„ç†å®ç°è¿™ä¸€æœºåˆ¶ï¼Œsvm_migrate_to_vram/ram å‡½æ•°è´Ÿè´£é¡µé¢åœ¨ CPU å’Œ GPU å†…å­˜ä¹‹é—´çš„æŒ‰éœ€è¿ç§»ã€‚',
            explanation: [
              'ä¼ ç»Ÿ GPU ç¼–ç¨‹ï¼ˆCUDA çš„æ—©æœŸæ¨¡å¼ï¼‰è¦æ±‚ç¨‹åºå‘˜æ˜¾å¼ç®¡ç†æ•°æ®ä¼ è¾“ï¼šcudaMalloc åœ¨ GPU ä¸Šåˆ†é…å†…å­˜ï¼ŒcudaMemcpy åœ¨ CPU å’Œ GPU ä¹‹é—´æ‹·è´æ•°æ®ã€‚è¿™ä¸ä»…ç¹çï¼Œè¿˜å®¹æ˜“å‡ºé”™â€”â€”å¿˜è®°åŒæ­¥ã€é‡å¤æ‹·è´ã€å†…å­˜æ³„æ¼ã€‚SVM çš„ç›®æ ‡æ˜¯æ¶ˆé™¤è¿™äº›æ‰‹åŠ¨æ­¥éª¤ï¼šåœ¨ CPU ä¸Šç”¨ malloc æˆ– mmap åˆ†é…çš„å†…å­˜ï¼ŒGPU å¯ä»¥ç›´æ¥é€šè¿‡ç›¸åŒçš„è™šæ‹Ÿåœ°å€è®¿é—®ï¼›åä¹‹äº¦ç„¶ã€‚',
              'SVM çš„å®ç°ä¾èµ–å‡ ä¸ªå…³é”®æœºåˆ¶ï¼šï¼ˆ1ï¼‰GPUVM é¡µè¡¨â€”â€”æ¯ä¸ªè¿›ç¨‹åœ¨ GPU ä¸Šæœ‰ç‹¬ç«‹çš„é¡µè¡¨ï¼ˆç±»ä¼¼ CPU çš„ MMU é¡µè¡¨ï¼‰ï¼Œå°†è™šæ‹Ÿåœ°å€æ˜ å°„åˆ°ç‰©ç†é¡µé¢ï¼ˆVRAM æˆ–ç³»ç»Ÿå†…å­˜ï¼‰ã€‚KFD é€šè¿‡ amdgpu çš„ VM å­ç³»ç»Ÿç®¡ç†è¿™äº›é¡µè¡¨ã€‚ï¼ˆ2ï¼‰PASIDï¼ˆProcess Address Space IDï¼‰â€”â€”æ¯ä¸ªè¿›ç¨‹åˆ†é…ä¸€ä¸ªå”¯ä¸€çš„ PASIDï¼ŒGPU åœ¨å‘å‡ºå†…å­˜è®¿é—®æ—¶æºå¸¦ PASIDï¼ŒIOMMU å’Œ GPUVM ç”¨å®ƒæ¥é€‰æ‹©æ­£ç¡®çš„é¡µè¡¨ã€‚è¿™å®ç°äº†è¿›ç¨‹çº§çš„ GPU å†…å­˜éš”ç¦»ã€‚ï¼ˆ3ï¼‰GPU page faultâ€”â€”å½“ GPU è®¿é—®çš„è™šæ‹Ÿåœ°å€åœ¨ GPUVM é¡µè¡¨ä¸­æ²¡æœ‰æœ‰æ•ˆæ˜ å°„æ—¶ï¼ŒGPU ç”Ÿæˆ page fault ä¸­æ–­ã€‚KFD çš„ fault handler æ•è·è¿™ä¸ªä¸­æ–­ï¼ŒæŒ‰éœ€å»ºç«‹æ˜ å°„ï¼ˆå¯èƒ½è§¦å‘é¡µé¢è¿ç§»ï¼‰ã€‚',
              'é¡µé¢è¿ç§»æ˜¯ SVM çš„æ€§èƒ½å…³é”®ã€‚å½“ GPU é¢‘ç¹è®¿é—®ç³»ç»Ÿå†…å­˜ä¸­çš„é¡µé¢æ—¶ï¼ŒKFD å¯ä»¥å°†é¡µé¢è¿ç§»åˆ° VRAM ä»¥è·å¾—æ›´é«˜å¸¦å®½ã€‚svm_migrate_to_vram() æ‰§è¡Œ RAM â†’ VRAM è¿ç§»ï¼šï¼ˆaï¼‰åœ¨ VRAM ä¸­åˆ†é…ç›®æ ‡é¡µé¢ï¼›ï¼ˆbï¼‰é€šè¿‡ SDMA å¼•æ“å¤åˆ¶æ•°æ®ï¼›ï¼ˆcï¼‰æ›´æ–° CPU å’Œ GPU é¡µè¡¨ï¼›ï¼ˆdï¼‰åœ¨ CPU é¡µè¡¨ä¸­å®‰è£…ä¸€ä¸ª migration entryï¼Œå¦‚æœ CPU ä¹‹åè®¿é—®è¿™ä¸ªé¡µé¢ï¼Œè§¦å‘ CPU page fault æŠŠé¡µé¢è¿å› RAMã€‚svm_migrate_to_ram() æ˜¯åæ–¹å‘çš„è¿ç§»ã€‚è¿™ç§æŒ‰éœ€è¿ç§»æœºåˆ¶ç±»ä¼¼äºæ“ä½œç³»ç»Ÿçš„ swapï¼Œä½†åœ¨ CPU å’Œ GPU å†…å­˜ä¹‹é—´è¿›è¡Œã€‚',
              'CPU-GPU å†…å­˜ä¸€è‡´æ€§ï¼ˆcoherencyï¼‰æ˜¯ SVM æœ€å¤æ‚çš„éƒ¨åˆ†ã€‚RDNA3 çš„ Navi33 æ”¯æŒé€šè¿‡ PCIe çš„ cache coherency åè®®ï¼ˆå¦‚ CCIX çš„å‰èº«æˆ– CXL ç›¸å…³æœºåˆ¶ï¼‰ï¼Œä½†åœ¨å®è·µä¸­ï¼ŒKFD æä¾›äº†ä¸åŒçº§åˆ«çš„ä¸€è‡´æ€§ä¿è¯ï¼šï¼ˆaï¼‰Coarse-grainedï¼šGPU åœ¨ kernel æ‰§è¡ŒæœŸé—´çœ‹åˆ°ä¸€è‡´çš„å¿«ç…§ï¼Œä½†ä¸ä¿è¯å®æ—¶ä¸€è‡´æ€§â€”â€”é€‚åˆå¤§å¤šæ•°è®¡ç®—åœºæ™¯ã€‚ï¼ˆbï¼‰Fine-grainedï¼šCPU å’Œ GPU å¯¹åŒä¸€åœ°å€çš„è¯»å†™éµå¾ªæŸç§é¡ºåºä¿è¯â€”â€”éœ€è¦ç¡¬ä»¶çº§åˆ«çš„ cache snoopï¼Œæ€§èƒ½å¼€é”€æ›´å¤§ã€‚ROCm ç”¨æˆ·å¯ä»¥é€šè¿‡ hsa_amd_memory_pool_allocate çš„ flags é€‰æ‹©ä¸€è‡´æ€§çº§åˆ«ã€‚',
            ],
            keyPoints: [
              'SVM è®© CPU/GPU å…±äº«è™šæ‹Ÿåœ°å€ç©ºé—´â€”â€”CPU æŒ‡é’ˆå¯åœ¨ GPU kernel ä¸­ç›´æ¥ä½¿ç”¨ï¼Œæ¶ˆé™¤æ˜¾å¼æ•°æ®æ‹·è´',
              'GPUVM é¡µè¡¨ä¸ºæ¯ä¸ªè¿›ç¨‹ç»´æŠ¤ç‹¬ç«‹çš„ GPU åœ°å€æ˜ å°„ï¼ŒPASID å®ç°è¿›ç¨‹éš”ç¦»',
              'GPU page fault è§¦å‘æŒ‰éœ€é¡µé¢æ˜ å°„â€”â€”ç±»ä¼¼ CPU çš„ demand paging æœºåˆ¶',
              'svm_migrate_to_vram() å°†çƒ­é¡µé¢è¿ç§»åˆ° VRAM æå‡ GPU è®¿é—®å¸¦å®½ï¼ˆSDMA å¼•æ“æ‰§è¡Œå®é™…æ‹·è´ï¼‰',
              'svm_migrate_to_ram() åœ¨ CPU éœ€è¦è®¿é—®å·²è¿ç§»é¡µé¢æ—¶è§¦å‘å›è¿',
              'KFD é€šè¿‡ MMU notifier ç›‘å¬è¿›ç¨‹é¡µè¡¨å˜åŒ–ï¼Œä¿æŒ GPUVM é¡µè¡¨ä¸ CPU é¡µè¡¨åŒæ­¥',
            ],
          },
          diagram: {
            title: 'SVM ç»Ÿä¸€è™šæ‹Ÿåœ°å€ç©ºé—´ä¸é¡µé¢è¿ç§»',
            content: `SVM ç»Ÿä¸€è™šæ‹Ÿåœ°å€ç©ºé—´ï¼šCPU å’Œ GPU å…±äº«æŒ‡é’ˆ

è¿›ç¨‹è™šæ‹Ÿåœ°å€ç©ºé—´ (64-bit)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  0x0000'7f00'0000'0000   â† malloc åˆ†é…çš„ç¼“å†²åŒº        â”‚
â”‚  0x0000'7f00'0001'0000   â† GPU kernel çš„å‚æ•°          â”‚
â”‚  0x0000'7f00'0002'0000   â† è®¡ç®—ç»“æœ                   â”‚
â”‚  ...                                                   â”‚
â”‚  CPU å’Œ GPU ä½¿ç”¨ç›¸åŒçš„è™šæ‹Ÿåœ°å€è®¿é—®è¿™äº›æ•°æ®             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚                            â”‚
     CPU MMU é¡µè¡¨                 GPUVM é¡µè¡¨
     (per-process)                (per-PASID)
           â”‚                            â”‚
           â–¼                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CPU ç‰©ç†å†…å­˜     â”‚          â”‚  GPU VRAM        â”‚
â”‚  (DDR5 RAM)      â”‚          â”‚  (GDDR6 8GB)     â”‚
â”‚                  â”‚          â”‚                  â”‚
â”‚  Page A [çƒ­æ•°æ®] â”‚ â”€â”€è¿ç§»â”€â”€â†’â”‚  Page A (å‰¯æœ¬)   â”‚
â”‚  (migration      â”‚          â”‚  é«˜å¸¦å®½ GPU è®¿é—®  â”‚
â”‚   entry æ ‡è®°)    â”‚          â”‚                  â”‚
â”‚                  â”‚          â”‚                  â”‚
â”‚  Page B          â”‚â†â”€â”€å›è¿â”€â”€ â”‚  Page B          â”‚
â”‚  (CPU è®¿é—®è§¦å‘)  â”‚          â”‚  (evicted)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

é¡µé¢è¿ç§»æµç¨‹ (svm_migrate_to_vram):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  1. GPU é¢‘ç¹è®¿é—® Page A â†’ è§¦å‘è¿ç§»å†³ç­–
  2. VRAM åˆ†é…ç›®æ ‡é¡µé¢
  3. SDMA å¼•æ“: memcpy(vram_page, ram_page)
  4. æ›´æ–° GPUVM é¡µè¡¨: VA â†’ VRAM ç‰©ç†åœ°å€
  5. æ›´æ–° CPU é¡µè¡¨: å®‰è£… migration entry
     (CPU å†è®¿é—®æ—¶è§¦å‘ fault â†’ svm_migrate_to_ram)

GPU Page Fault å¤„ç†:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  GPU è®¿é—®è™šæ‹Ÿåœ°å€ 0x7f0000010000
       â”‚
       â–¼ (GPUVM é¡µè¡¨æ— æ˜ å°„)
  GPU äº§ç”Ÿ page fault ä¸­æ–­
       â”‚
       â–¼
  KFD fault handler (kfd_svm_page_fault)
       â”‚
       â”œâ”€ åœ°å€å±äºå·²æ³¨å†Œ SVM rangeï¼Ÿ
       â”‚   æ˜¯ â†’ å»ºç«‹ GPUVM æ˜ å°„ï¼ˆå¯èƒ½è§¦å‘è¿ç§»ï¼‰
       â”‚   å¦ â†’ æŠ¥å‘Š GPU fault é”™è¯¯
       â”‚
       â–¼
  æ¢å¤ GPU æ‰§è¡Œ`,
            caption: 'SVM è®© CPU å’Œ GPU é€šè¿‡ç›¸åŒçš„è™šæ‹Ÿåœ°å€è®¿é—®æ•°æ®ã€‚é¡µé¢å¯ä»¥åœ¨ç³»ç»Ÿå†…å­˜å’Œ VRAM ä¹‹é—´æŒ‰éœ€è¿ç§»â€”â€”GPU çƒ­æ•°æ®è‡ªåŠ¨è¿å…¥ VRAM ä»¥è·å¾—é«˜å¸¦å®½ï¼ŒCPU è®¿é—®æ—¶è‡ªåŠ¨è¿å›ã€‚è¿™å¯¹åº”ç”¨ç¨‹åºé€æ˜ï¼Œç”± KFD å’Œç¡¬ä»¶ page fault æœºåˆ¶è‡ªåŠ¨ç®¡ç†ã€‚',
          },
          codeWalk: {
            title: 'svm_range_add â€” æ³¨å†Œ SVM è™šæ‹Ÿåœ°å€èŒƒå›´',
            file: 'drivers/gpu/drm/amd/amdkfd/kfd_svm.c',
            language: 'c',
            code: `/* kfd_svm.c â€” SVM èŒƒå›´ç®¡ç†æ ¸å¿ƒå‡½æ•° */

/* svm_range è¡¨ç¤ºä¸€æ®µå— SVM ç®¡ç†çš„è™šæ‹Ÿåœ°å€åŒºé—´ */
struct svm_range {
    struct interval_tree_node it_node; /* åŒºé—´æ ‘èŠ‚ç‚¹ï¼ŒæŒ‰ VA ç´¢å¼• */
    struct list_head list;             /* è¿›ç¨‹çš„ SVM range é“¾è¡¨ */
    uint64_t start;                    /* èµ·å§‹é¡µé¢ç¼–å· (VA >> PAGE_SHIFT) */
    uint64_t last;                     /* ç»“æŸé¡µé¢ç¼–å· */
    uint64_t npages;                   /* é¡µé¢æ•°é‡ */
    uint32_t flags;                    /* è®¿é—®æ ‡å¿— */
    uint32_t preferred_loc;            /* é¦–é€‰ä½ç½®ï¼šCPU æˆ– GPU_ID */
    uint32_t actual_loc;               /* å½“å‰å®é™…ä½ç½® */
    uint32_t granularity;              /* è¿ç§»ç²’åº¦ */
    struct list_head deferred_list;    /* å»¶è¿Ÿæ›´æ–°åˆ—è¡¨ */
    struct mutex migrate_mutex;        /* è¿ç§»æ“ä½œäº’æ–¥é” */
    atomic_t queue_refcount;           /* å¼•ç”¨æ­¤ range çš„é˜Ÿåˆ—æ•° */
    /* ... æ›´å¤šå­—æ®µ */
};

/* æ³¨å†Œä¸€æ®µè™šæ‹Ÿåœ°å€ä¸º SVM ç®¡ç†åŒºåŸŸ */
int svm_range_add(struct kfd_process *p,
                  uint64_t start, uint64_t size,
                  uint32_t nattr,
                  struct kfd_ioctl_svm_attribute *attrs)
{
    struct svm_range_list *svms = &p->svms;
    struct svm_range *prange;
    uint64_t last = start + size - 1;
    int r;

    /* é”å®š SVM range åˆ—è¡¨ */
    mutex_lock(&svms->lock);

    /* æ£€æŸ¥æ˜¯å¦ä¸å·²æœ‰ SVM range é‡å 
     * ä½¿ç”¨ interval_tree é«˜æ•ˆæŸ¥æ‰¾é‡å åŒºé—´
     */
    prange = svm_range_find(svms, start, last);
    if (prange) {
        /* å·²æœ‰ range è¦†ç›–æ­¤åŒºåŸŸï¼šæ›´æ–°å±æ€§ */
        r = svm_range_split_adjust(svms, prange,
                                   start, last, nattr, attrs);
        goto out;
    }

    /* åˆ†é…æ–°çš„ svm_range ç»“æ„ä½“ */
    prange = svm_range_new(svms, start, size, true);
    if (!prange) {
        r = -ENOMEM;
        goto out;
    }

    /* è®¾ç½® SVM å±æ€§ï¼ˆpreferred_loc, flags ç­‰ï¼‰
     * preferred_loc å†³å®šé¡µé¢é¦–é€‰å­˜æ”¾ä½ç½®ï¼š
     *   KFD_IOCTL_SVM_LOCATION_SYSMEM â€” ç³»ç»Ÿå†…å­˜
     *   KFD_IOCTL_SVM_LOCATION_VRAM   â€” GPU æ˜¾å­˜
     */
    svm_range_set_attr(p, start, size, nattr, attrs);

    /* å°†æ–° range åŠ å…¥åŒºé—´æ ‘å’Œé“¾è¡¨ */
    svm_range_add_to_svms(prange);
    svm_range_add_notifier_locked(svms, prange);

    r = 0;
out:
    mutex_unlock(&svms->lock);
    return r;
}`,
            annotations: [
              'svm_range æ˜¯ SVM çš„æ ¸å¿ƒæ•°æ®ç»“æ„ï¼Œæ¯ä¸ªå®ä¾‹ä»£è¡¨ä¸€æ®µå—ç®¡ç†çš„è™šæ‹Ÿåœ°å€åŒºé—´',
              'interval_tree å…è®¸é«˜æ•ˆæŸ¥æ‰¾ä¸ç»™å®šåœ°å€èŒƒå›´é‡å çš„ SVM rangeï¼ˆO(log n) å¤æ‚åº¦ï¼‰',
              'preferred_loc æŒ‡ç¤ºé¡µé¢åº”ä¼˜å…ˆæ”¾åœ¨ CPU è¿˜æ˜¯ GPU å†…å­˜â€”â€”å½±å“è¿ç§»ç­–ç•¥',
              'actual_loc è®°å½•é¡µé¢å½“å‰å®é™…ä½ç½®ï¼Œä¸ preferred_loc ä¸åŒæ—¶å¯èƒ½è§¦å‘è¿ç§»',
              'migrate_mutex ä¿æŠ¤è¿ç§»æ“ä½œâ€”â€”åŒä¸€æ—¶é—´åªå…è®¸ä¸€ä¸ªè¿ç§»æ“ä½œè¿›è¡Œ',
              'svm_range_add_notifier_locked æ³¨å†Œ MMU notifierï¼Œå½“ CPU é¡µè¡¨å˜åŒ–æ—¶é€šçŸ¥ KFD æ›´æ–° GPUVM',
            ],
            explanation: 'svm_range_add æ˜¯ ROCm è¿è¡Œæ—¶å‘ KFD æ³¨å†Œ SVM ç®¡ç†åŒºåŸŸçš„å…¥å£ã€‚å½“ç”¨æˆ·ç©ºé—´è°ƒç”¨ hsaKmtSetMemoryPolicy æˆ– hipMallocManaged æ—¶ï¼Œæœ€ç»ˆä¼šé€šè¿‡ ioctl è°ƒç”¨æ­¤å‡½æ•°ã€‚å®ƒåœ¨ KFD ä¸­åˆ›å»ºä¸€ä¸ª svm_range ç»“æ„ä½“æ¥è·Ÿè¸ªè¿™æ®µè™šæ‹Ÿåœ°å€ï¼Œåç»­å½“ GPU è®¿é—®æ­¤èŒƒå›´å†…çš„åœ°å€æ—¶ï¼ŒKFD çš„ page fault handler å¯ä»¥æŸ¥æ‰¾åˆ°å¯¹åº”çš„ svm_range å¹¶æŒ‰éœ€å»ºç«‹æ˜ å°„æˆ–è§¦å‘è¿ç§»ã€‚è¿™æ˜¯ SVM "æŒ‰éœ€åˆ†é…ã€æŒ‰éœ€è¿ç§»" æœºåˆ¶çš„èµ·ç‚¹ã€‚',
          },
          miniLab: {
            title: 'è§‚å¯Ÿ SVM é¡µé¢è¿ç§»å’Œ GPU page fault',
            objective: 'é€šè¿‡ ftrace å’Œ sysfs è§‚å¯Ÿ KFD çš„ SVM é¡µé¢è¿ç§»è¡Œä¸ºï¼Œç†è§£æŒ‰éœ€è¿ç§»çš„å·¥ä½œæ–¹å¼ã€‚',
            setup: `# éœ€è¦ root æƒé™æ¥ä½¿ç”¨ ftrace
# éœ€è¦å®‰è£… ROCm å’Œä¸€ä¸ªä½¿ç”¨ managed memory çš„ HIP ç¨‹åº
sudo su`,
            steps: [
              'å¯ç”¨ KFD SVM ç›¸å…³çš„ ftrace è·Ÿè¸ªç‚¹ï¼šecho 1 > /sys/kernel/debug/tracing/events/amdgpu/svm_migrate_start/enable',
              'åŒæ—¶å¯ç”¨ GPU fault äº‹ä»¶ï¼šecho 1 > /sys/kernel/debug/tracing/events/amdgpu/amdgpu_vm_bo_cs/enable',
              'è¿è¡Œä¸€ä¸ªä½¿ç”¨ hipMallocManaged çš„ HIP ç¨‹åº',
              'æŸ¥çœ‹ ftrace æ—¥å¿—ï¼šcat /sys/kernel/debug/tracing/trace | grep svm',
              'è§‚å¯Ÿè¿ç§»ç»Ÿè®¡ï¼šcat /sys/class/drm/card0/device/kfd/proc/*/svm_statsï¼ˆå¦‚æœå¯ç”¨ï¼‰',
              'æ¸…ç† ftraceï¼šecho 0 > /sys/kernel/debug/tracing/events/amdgpu/svm_migrate_start/enable',
            ],
            expectedOutput: `$ cat /sys/kernel/debug/tracing/trace | grep svm
vectorAdd-12345 [003]  svm_migrate_start: pid=12345
  src=RAM dst=VRAM start=0x7f0000010000 npages=64
vectorAdd-12345 [003]  svm_migrate_end: pid=12345
  src=RAM dst=VRAM migrated=64 failed=0

è¯´æ˜ï¼š64 ä¸ªé¡µé¢ï¼ˆ256KBï¼‰ä» RAM è¿ç§»åˆ° VRAM
è¿™å‘ç”Ÿåœ¨ GPU kernel é¦–æ¬¡è®¿é—® managed memory æ—¶`,
            hint: 'å¦‚æœ ftrace äº‹ä»¶ç‚¹ä¸å­˜åœ¨ï¼Œå¯èƒ½æ˜¯å†…æ ¸ç‰ˆæœ¬è¾ƒæ—§ã€‚å¯ä»¥æ”¹ç”¨ dmesg è§‚å¯Ÿï¼šecho 0x40 > /sys/module/amdgpu/parameters/debug_mask å¯ç”¨ KFD è°ƒè¯•æ—¥å¿—ã€‚',
          },
          debugExercise: {
            title: 'è¯Šæ–­ GPU page fault å¯¼è‡´çš„ kernel å´©æºƒ',
            language: 'c',
            description: 'ä¸€ä¸ª HIP ç¨‹åºåœ¨ GPU kernel æ‰§è¡Œæ—¶å´©æºƒï¼Œdmesg æ˜¾ç¤º GPU VM faultã€‚åˆ†æé”™è¯¯ä¿¡æ¯å¹¶ç¡®å®šæ ¹æœ¬åŸå› ã€‚',
            question: 'GPU VM fault çš„æ ¹æœ¬åŸå› æ˜¯ä»€ä¹ˆï¼Ÿå¦‚ä½•åœ¨ HIP ä»£ç ä¸­é¿å…è¿™ç±»é—®é¢˜ï¼Ÿ',
            buggyCode: `/* dmesg è¾“å‡º */
[  89.3] amdgpu 0000:03:00.0: [gfxhub0]
  GPU fault detected: src_id:0, ring:0, vmid:3, pasid:32769
[  89.3] amdgpu 0000:03:00.0:
  VM_L2_PROTECTION_FAULT_STATUS: 0x00301050
[  89.3] amdgpu 0000:03:00.0:
  addr: 0x00007f0000DEAD00  â† è¢«è®¿é—®çš„è™šæ‹Ÿåœ°å€
  status: read, protection fault
  client: TCP (Texture Cache Per Pipe)
[  89.3] kfd: Process 12345 GPU fault on gpu 1002:7480

/* å¯¹åº”çš„æœ‰é—®é¢˜çš„ HIP ä»£ç  */
__global__ void kernel(int *data, int n) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    /* BUG: æ²¡æœ‰æ£€æŸ¥ idx < n å°±è®¿é—® data[idx] */
    data[idx] = data[idx] * 2;  /* è¶Šç•Œè®¿é—®! */
}

int main() {
    int *d_data;
    int n = 1024;
    hipMalloc(&d_data, n * sizeof(int));
    /* å¯åŠ¨äº†è¿‡å¤šçš„çº¿ç¨‹ï¼š2048 > 1024 */
    kernel<<<4, 512>>>(d_data, n);
    hipDeviceSynchronize();
}`,
            hint: 'æ³¨æ„ addr ä¸­çš„ 0xDEAD00 æ¨¡å¼ï¼Œä»¥åŠçº¿ç¨‹æ•°é‡ï¼ˆ4 * 512 = 2048ï¼‰å’Œæ•°æ®å¤§å°ï¼ˆ1024 ä¸ª intï¼‰çš„ä¸åŒ¹é…ã€‚',
            answer: 'æ ¹æœ¬åŸå› ï¼šGPU kernel è¶Šç•Œå†…å­˜è®¿é—®ã€‚ç¨‹åºåˆ†é…äº† 1024 ä¸ª intï¼ˆ4KBï¼‰ï¼Œä½†å¯åŠ¨äº† 4 * 512 = 2048 ä¸ªçº¿ç¨‹ï¼Œçº¿ç¨‹ 1024-2047 è®¿é—® data[1024]-data[2047]ï¼Œè¶…å‡ºäº†åˆ†é…çš„å†…å­˜èŒƒå›´ã€‚GPU çš„ GPUVM åœ¨è¿™äº›è¶Šç•Œåœ°å€ä¸Šæ²¡æœ‰æœ‰æ•ˆæ˜ å°„ï¼Œå¯¼è‡´ VM_L2_PROTECTION_FAULTã€‚dmesg ä¸­çš„å…³é”®ä¿¡æ¯ï¼šï¼ˆ1ï¼‰pasid:32769 æ ‡è¯†äº†å‡ºé”™è¿›ç¨‹ï¼›ï¼ˆ2ï¼‰addr: 0x7f0000DEAD00 æ˜¯è¶Šç•Œè®¿é—®çš„è™šæ‹Ÿåœ°å€ï¼ˆ0xDEAD æ¨¡å¼è¡¨æ˜è¿™å¯èƒ½æ˜¯æœªåˆå§‹åŒ–æˆ–å·²é‡Šæ”¾çš„å†…å­˜åŒºåŸŸï¼‰ï¼›ï¼ˆ3ï¼‰client: TCP è¡¨ç¤ºæ˜¯ Texture Cache å‘èµ·çš„è¯»æ“ä½œï¼ˆè®¡ç®— shader çš„å†…å­˜è¯»å–ä¹Ÿé€šè¿‡ TCPï¼‰ï¼›ï¼ˆ4ï¼‰protection fault è¡¨ç¤ºé¡µè¡¨ä¸­æ²¡æœ‰æ­¤åœ°å€çš„æ˜ å°„ã€‚ä¿®å¤æ–¹æ³•ï¼šåœ¨ kernel ä¸­æ·»åŠ è¾¹ç•Œæ£€æŸ¥ if (idx < n)ï¼Œæˆ–è€…è°ƒæ•´ grid å¤§å°åŒ¹é…æ•°æ®é‡ï¼škernel<<<(n+255)/256, 256>>>(d_data, n)ã€‚è¿™æ˜¯ GPU ç¼–ç¨‹ä¸­æœ€å¸¸è§çš„ bug ç±»å‹ä¹‹ä¸€ã€‚',
          },
          interviewQ: {
            question: 'è§£é‡Š KFD çš„ SVMï¼ˆShared Virtual Memoryï¼‰æ˜¯å¦‚ä½•å®ç°çš„ã€‚åŒ…æ‹¬ GPUVM é¡µè¡¨ã€PASIDã€GPU page fault å’Œé¡µé¢è¿ç§»çš„å·¥ä½œæœºåˆ¶ã€‚',
            difficulty: 'hard',
            hint: 'ä»æ•°æ®ç»“æ„ï¼ˆsvm_rangeï¼‰â†’ ç¡¬ä»¶æœºåˆ¶ï¼ˆGPUVMã€PASIDã€page faultï¼‰â†’ è¿ç§»æµç¨‹ï¼ˆsvm_migrate_to_vram/ramï¼‰â†’ ä¸€è‡´æ€§ä¿è¯ï¼ˆMMU notifierï¼‰çš„é¡ºåºå›ç­”ã€‚',
            answer: 'KFD SVM å®ç°ï¼šï¼ˆ1ï¼‰æ•°æ®ç»“æ„ï¼šæ¯æ®µå— SVM ç®¡ç†çš„è™šæ‹Ÿåœ°å€åŒºé—´ç”¨ svm_range è¡¨ç¤ºï¼Œå­˜å‚¨åœ¨ interval tree ä¸­ä»¥é«˜æ•ˆæŸ¥æ‰¾ã€‚svm_range è®°å½•äº†åœ°å€èŒƒå›´ã€é¦–é€‰ä½ç½®ï¼ˆCPU/GPUï¼‰ã€å®é™…ä½ç½®å’Œè¿ç§»çŠ¶æ€ã€‚ï¼ˆ2ï¼‰GPUVM é¡µè¡¨ï¼šæ¯ä¸ªè¿›ç¨‹çš„ GPU æœ‰ç‹¬ç«‹çš„é¡µè¡¨ï¼ˆç±»ä¼¼ CPU çš„ 4 çº§é¡µè¡¨ï¼‰ï¼Œå°†è™šæ‹Ÿåœ°å€æ˜ å°„åˆ° VRAM æˆ–ç³»ç»Ÿå†…å­˜çš„ç‰©ç†åœ°å€ã€‚PASID æ˜¯è¿›ç¨‹çš„åœ°å€ç©ºé—´æ ‡è¯†ï¼ŒGPU è®¿é—®å†…å­˜æ—¶æºå¸¦ PASIDï¼Œç¡¬ä»¶ç”¨å®ƒé€‰æ‹©æ­£ç¡®çš„é¡µè¡¨ã€‚ï¼ˆ3ï¼‰GPU page faultï¼šå½“ GPU è®¿é—®æœªæ˜ å°„çš„è™šæ‹Ÿåœ°å€æ—¶ï¼ŒGPU äº§ç”Ÿ page fault ä¸­æ–­ã€‚KFD çš„ kfd_svm_page_fault handler æŸ¥æ‰¾å¯¹åº”çš„ svm_rangeï¼Œå¦‚æœé¡µé¢åœ¨ç³»ç»Ÿå†…å­˜ä¸”éœ€è¦è¿ç§»åˆ° VRAMï¼Œè§¦å‘ svm_migrate_to_vram()ï¼šåœ¨ VRAM åˆ†é…é¡µé¢ â†’ SDMA å¤åˆ¶æ•°æ® â†’ æ›´æ–° GPU é¡µè¡¨ â†’ åœ¨ CPU é¡µè¡¨å®‰è£… migration entryã€‚ï¼ˆ4ï¼‰åå‘è¿ç§»ï¼šCPU è®¿é—®å·²è¿ç§»åˆ° VRAM çš„é¡µé¢æ—¶ï¼ŒCPU page fault handler è§¦å‘ svm_migrate_to_ram() å°†é¡µé¢è¿å›ã€‚ï¼ˆ5ï¼‰ä¸€è‡´æ€§ï¼šKFD æ³¨å†Œ MMU notifierï¼Œå½“ CPU ä¾§é¡µè¡¨å˜åŒ–ï¼ˆå¦‚ munmapã€mremapï¼‰æ—¶ï¼ŒKFD åŒæ­¥æ›´æ–°æˆ– invalidate å¯¹åº”çš„ GPUVM æ˜ å°„ï¼Œä¿è¯ CPU å’Œ GPU çœ‹åˆ°ä¸€è‡´çš„åœ°å€ç©ºé—´ã€‚æ•´ä¸ªæœºåˆ¶å¯¹ç”¨æˆ·ç©ºé—´é€æ˜â€”â€”hipMallocManaged åˆ†é…çš„å†…å­˜è‡ªåŠ¨åœ¨éœ€è¦æ—¶è¿ç§»åˆ°æ­£ç¡®çš„ä½ç½®ã€‚',
            amdContext: 'è¿™æ˜¯ AMD ROCm é¢è¯•ä¸­çš„é«˜çº§é—®é¢˜ã€‚å±•ç¤ºä½ ç†è§£ SVM ä¸åªæ˜¯"å…±äº«åœ°å€"é‚£ä¹ˆç®€å•ï¼ŒèƒŒåæ˜¯ GPUVM é¡µè¡¨ã€PASID ç¡¬ä»¶æ”¯æŒã€page fault å¤„ç†å’ŒåŒå‘è¿ç§»çš„å¤æ‚ç³»ç»Ÿã€‚æåˆ° MMU notifier æ˜¯åŠ åˆ†é¡¹â€”â€”å®ƒä½“ç°äº†ä½ ç†è§£ CPU å’Œ GPU é¡µè¡¨åŒæ­¥çš„å…³é”®æœºåˆ¶ã€‚',
          },
        },

        // â”€â”€ Lesson 7.2.2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        {
          id: '7-2-2',
          number: '7.2.2',
          title: 'ä¿¡å·é‡ä¸äº‹ä»¶ï¼šCPU-GPU åŒæ­¥',
          titleEn: 'Signals & Events: CPU-GPU Synchronization',
          duration: 18,
          difficulty: 'advanced',
          tags: ['HSA-signal', 'KFD-event', 'doorbell', 'interrupt', 'polling', 'synchronization'],
          concept: {
            summary: 'CPU-GPU åŒæ­¥æ˜¯å¼‚æ„è®¡ç®—ä¸­çš„æ ¸å¿ƒæŒ‘æˆ˜ã€‚KFD æä¾›ä¸¤ç§æœºåˆ¶ï¼šHSA ä¿¡å·é‡ï¼ˆ64 ä½åŸå­è®¡æ•°å™¨ï¼Œæ”¯æŒ GPU ç›´æ¥æ›´æ–°ï¼‰å’Œ KFD äº‹ä»¶ï¼ˆä¸­æ–­é©±åŠ¨çš„å”¤é†’æœºåˆ¶ï¼‰ã€‚ä¿¡å·é‡ç”¨äº GPU-GPU å’Œ CPU-GPU ä¹‹é—´çš„ç»†ç²’åº¦åŒæ­¥ï¼Œäº‹ä»¶ç”¨äº CPU ç­‰å¾… GPU å®Œæˆçš„é«˜æ•ˆé˜»å¡ã€‚',
            explanation: [
              'HSA ä¿¡å·é‡ï¼ˆHSA Signalï¼‰æ˜¯ä¸€ä¸ª 64 ä½åŸå­å€¼ï¼Œå­˜å‚¨åœ¨ CPU å’Œ GPU éƒ½èƒ½è®¿é—®çš„å†…å­˜ä½ç½®ã€‚GPU å¯ä»¥é€šè¿‡åŸå­æ“ä½œæ›´æ–°ä¿¡å·é‡çš„å€¼ï¼ˆä¾‹å¦‚å®Œæˆä¸€ä¸ª kernel åå°†å…¶é€’å‡ä¸º 0ï¼‰ï¼ŒCPU å¯ä»¥è½®è¯¢æˆ–ç­‰å¾…ä¿¡å·é‡è¾¾åˆ°ç‰¹å®šå€¼ã€‚ä¿¡å·é‡çš„æœ¬è´¨æ˜¯ä¸€ä¸ªå…±äº«çš„åŸå­è®¡æ•°å™¨ï¼Œä½†å®ƒçš„ç‰¹æ®Šä¹‹å¤„åœ¨äºï¼šå®ƒå…³è”äº†ä¸€ä¸ª KFD äº‹ä»¶ï¼Œå½“ä¿¡å·é‡çš„å€¼æ»¡è¶³æ¡ä»¶æ—¶ï¼Œå¯ä»¥è§¦å‘ä¸­æ–­æ¥å”¤é†’ç­‰å¾…çš„ CPU çº¿ç¨‹ï¼Œè€Œä¸æ˜¯æµªè´¹ CPU å‘¨æœŸè½®è¯¢ã€‚',
              'åœ¨ AQL åŒ…ä¸­ï¼Œæ¯ä¸ª kernel dispatch åŒ…å«ä¸€ä¸ª completion_signal å­—æ®µã€‚å½“ GPU å®Œæˆæ­¤ dispatch åï¼Œå®ƒä¼šå¯¹ completion_signal æŒ‡å‘çš„ 64 ä½å€¼æ‰§è¡ŒåŸå­é€’å‡æ“ä½œã€‚å¦‚æœé€’å‡åçš„å€¼ç­‰äº 0ï¼ŒGPU è¿˜ä¼šå‘ CPU å‘é€ä¸€ä¸ªä¸­æ–­ï¼ˆé€šè¿‡å†™å…¥ IH Ringï¼‰ã€‚KFD çš„ä¸­æ–­å¤„ç†ç¨‹åºæ”¶åˆ°ä¸­æ–­åï¼ŒæŸ¥æ‰¾å¯¹åº”çš„ KFD äº‹ä»¶ï¼Œå”¤é†’ç­‰å¾…åœ¨è¯¥äº‹ä»¶ä¸Šçš„ CPU çº¿ç¨‹ã€‚è¿™å°±æ˜¯ hipDeviceSynchronize() æˆ– hipStreamSynchronize() çš„åº•å±‚å®ç°ã€‚',
              'KFD äº‹ä»¶ï¼ˆKFD Eventï¼‰æ˜¯å†…æ ¸ä¾§çš„åŒæ­¥åŸè¯­ã€‚ç”¨æˆ·ç©ºé—´é€šè¿‡ AMDKFD_IOC_CREATE_EVENT ioctl åˆ›å»ºäº‹ä»¶ï¼Œé€šè¿‡ AMDKFD_IOC_WAIT_EVENTS ç­‰å¾…äº‹ä»¶è§¦å‘ã€‚äº‹ä»¶æœ‰å¤šç§ç±»å‹ï¼šSIGNAL äº‹ä»¶ï¼ˆä¸ HSA ä¿¡å·é‡å…³è”ï¼ŒGPU å®Œæˆæ“ä½œåè§¦å‘ï¼‰ã€HW_EXCEPTIONï¼ˆGPU ç¡¬ä»¶å¼‚å¸¸ï¼Œå¦‚ page faultï¼‰ã€DEBUGï¼ˆè°ƒè¯•äº‹ä»¶ï¼‰ã€‚kfd_wait_on_event å‡½æ•°å®ç°äº†ç­‰å¾…é€»è¾‘ï¼šå°†å½“å‰çº¿ç¨‹åŠ å…¥ç­‰å¾…é˜Ÿåˆ—ï¼Œè®¾ç½®è¶…æ—¶ï¼Œå½“äº‹ä»¶è¢«è§¦å‘æ—¶å”¤é†’çº¿ç¨‹ã€‚',
              'åŒæ­¥æ¨¡å¼æœ‰ä¸¤ç§é€‰æ‹©ï¼šè½®è¯¢ï¼ˆpollingï¼‰å’Œä¸­æ–­ï¼ˆinterruptï¼‰ã€‚è½®è¯¢æ¨¡å¼ä¸‹ï¼ŒCPU æŒç»­è¯»å–ä¿¡å·é‡çš„å€¼ç›´åˆ°æ»¡è¶³æ¡ä»¶â€”â€”å»¶è¿Ÿæœ€ä½ï¼ˆ~100ns çº§åˆ«ï¼‰ï¼Œä½†æµªè´¹ CPU å‘¨æœŸã€‚ä¸­æ–­æ¨¡å¼ä¸‹ï¼ŒCPU çº¿ç¨‹ä¼‘çœ ï¼ŒGPU å®Œæˆåé€šè¿‡ä¸­æ–­å”¤é†’â€”â€”ä¸æµªè´¹ CPUï¼Œä½†ä¸­æ–­å¤„ç†æœ‰é¢å¤–å»¶è¿Ÿï¼ˆ~1-10Î¼sï¼‰ã€‚ROCm è¿è¡Œæ—¶é€šå¸¸é‡‡ç”¨æ··åˆç­–ç•¥ï¼šå…ˆè½®è¯¢ä¸€å°æ®µæ—¶é—´ï¼ˆ~1000 æ¬¡å¾ªç¯ï¼‰ï¼Œå¦‚æœä¿¡å·é‡ä»æœªå°±ç»ªï¼Œåˆ‡æ¢åˆ°ä¸­æ–­ç­‰å¾…ã€‚è¿™åœ¨çŸ­ kernelï¼ˆå¾®ç§’çº§å®Œæˆï¼‰æ—¶è·å¾—è½®è¯¢çš„ä½å»¶è¿Ÿï¼Œåœ¨é•¿ kernelï¼ˆæ¯«ç§’çº§ä»¥ä¸Šï¼‰æ—¶é¿å…æµªè´¹ CPUã€‚',
              'Doorbell åœ¨åŒæ­¥æœºåˆ¶ä¸­ä¹Ÿæ‰®æ¼”é‡è¦è§’è‰²ã€‚é™¤äº†ç”¨äºé€šçŸ¥ GPU æœ‰æ–°çš„ AQL åŒ…ï¼ˆé˜Ÿåˆ— doorbellï¼‰ï¼Œdoorbell è¿˜ç”¨äº HSA ä¿¡å·é‡çš„å¿«é€Ÿè·¯å¾„â€”â€”ç”¨æˆ·ç©ºé—´å¯ä»¥é€šè¿‡å†™ doorbell æ¥è§¦å‘ GPU æ£€æŸ¥ä¿¡å·é‡å€¼ã€‚è¿™ç§ doorbell-based signaling æœºåˆ¶è®©ä¿¡å·é‡æ“ä½œçš„å»¶è¿Ÿé™åˆ°æœ€ä½ã€‚KFD ä¸ºæ¯ä¸ªè¿›ç¨‹åˆ†é… doorbell é¡µé¢ï¼Œç”¨æˆ·ç©ºé—´é€šè¿‡ mmap /dev/kfd è·å¾— doorbell çš„è™šæ‹Ÿåœ°å€ã€‚',
            ],
            keyPoints: [
              'HSA Signal æ˜¯ 64 ä½åŸå­è®¡æ•°å™¨ï¼ŒGPU é€šè¿‡åŸå­æ“ä½œæ›´æ–°ï¼ŒCPU è½®è¯¢æˆ–ä¸­æ–­ç­‰å¾…',
              'AQL åŒ…çš„ completion_signal å­—æ®µâ€”â€”GPU å®Œæˆ dispatch åé€’å‡ï¼Œå€¼ä¸º 0 æ—¶è§¦å‘ä¸­æ–­',
              'KFD Event æ˜¯å†…æ ¸åŒæ­¥åŸè¯­â€”â€”SIGNALã€HW_EXCEPTIONã€DEBUG ç­‰ç±»å‹',
              'kfd_wait_on_event å®ç°é˜»å¡ç­‰å¾…ï¼šçº¿ç¨‹ä¼‘çœ  â†’ GPU ä¸­æ–­ â†’ kfd_signal_event_handler å”¤é†’',
              'æ··åˆåŒæ­¥ç­–ç•¥ï¼šå…ˆè½®è¯¢ï¼ˆä½å»¶è¿Ÿï¼‰â†’ è¶…æ—¶ååˆ‡æ¢åˆ°ä¸­æ–­ç­‰å¾…ï¼ˆèŠ‚çœ CPUï¼‰',
              'doorbell ç”¨äºé˜Ÿåˆ—é€šçŸ¥å’Œä¿¡å·é‡å¿«é€Ÿè·¯å¾„â€”â€”å•æ¬¡ 4 å­—èŠ‚ MMIO å†™å…¥',
            ],
          },
          diagram: {
            title: 'CPU-GPU åŒæ­¥ï¼šä¿¡å·é‡ä¸äº‹ä»¶æœºåˆ¶',
            content: `CPU-GPU åŒæ­¥çš„ä¸‰æ¡è·¯å¾„

è·¯å¾„ 1: è½®è¯¢æ¨¡å¼ (æœ€ä½å»¶è¿Ÿ, æ¶ˆè€— CPU)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  CPU                                GPU
  â”€â”€â”€â”€                               â”€â”€â”€â”€
  dispatch kernel (write AQL + doorbell)
                                     â”€â”€â†’ æ‰§è¡Œ kernel
  while (*signal != 0)               ...
    pause();         â† CPU å¿™ç­‰       ...
                                     å®Œæˆ
                                     atomic_dec(signal)
  *signal == 0  âœ“                    â”€â”€â†’ signal = 0
  å»¶è¿Ÿ: ~100ns (æœ€å¿«)

è·¯å¾„ 2: ä¸­æ–­æ¨¡å¼ (èŠ‚çœ CPU, æœ‰å»¶è¿Ÿ)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  CPU                                GPU
  â”€â”€â”€â”€                               â”€â”€â”€â”€
  dispatch kernel
  kfd_wait_on_event()                â”€â”€â†’ æ‰§è¡Œ kernel
    â”‚                                ...
    â–¼                                ...
  thread_sleep()    â† CPU ä¼‘çœ        ...
    zzz...                           å®Œæˆ
                                     atomic_dec(signal)
                                     if signal == 0:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    write IH Ring â†â”€â”
  â”‚                                   (ä¸­æ–­)           â”‚
  â–¼                                                    â”‚
  IH Ring å¤„ç†                                         â”‚
  kfd_signal_event_handler()                           â”‚
    â”‚                                                  â”‚
    â”œâ”€ æŸ¥æ‰¾äº‹ä»¶: event_id â†’ kfd_event                  â”‚
    â”œâ”€ è®¾ç½® event->signaled = true                     â”‚
    â””â”€ wake_up(&event->wq)  â† å”¤é†’ç­‰å¾…çº¿ç¨‹            â”‚
                                                       â”‚
  thread è¢«å”¤é†’ âœ“                                      â”‚
  å»¶è¿Ÿ: ~1-10Î¼s                                        â”‚
                                                       â”‚
è·¯å¾„ 3: æ··åˆæ¨¡å¼ (ROCm é»˜è®¤)                           â”‚
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•          â”‚
  CPU                                                  â”‚
  â”€â”€â”€â”€                                                 â”‚
  for (i = 0; i < 1000; i++)    â† å…ˆè½®è¯¢              â”‚
    if (*signal == 0) goto done;                       â”‚
  kfd_wait_on_event()           â† ç„¶åä¸­æ–­ç­‰å¾…         â”‚
                                                       â”‚
                                                       â”‚
IH Ring (Interrupt Handler Ring):                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  GPU äº§ç”Ÿçš„ä¸­æ–­äº‹ä»¶ç¯å½¢ç¼“å†²åŒº          â”‚             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”         â”‚             â”‚
â”‚  â”‚ src  â”‚ src  â”‚ src  â”‚      â”‚         â”‚             â”‚
â”‚  â”‚ =146 â”‚ =146 â”‚ =0   â”‚      â”‚         â”‚             â”‚
â”‚  â”‚signalâ”‚signalâ”‚fault â”‚      â”‚         â”‚             â”‚
â”‚  â”‚event1â”‚event2â”‚      â”‚      â”‚  â†â”€â”€â”€â”€â”€â”€â”˜
â”‚  â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
â”‚  kfd_interrupt_isr() é€ä¸ªå¤„ç†
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜`,
            caption: 'CPU-GPU åŒæ­¥çš„ä¸‰ç§æ¨¡å¼ã€‚è½®è¯¢å»¶è¿Ÿæœ€ä½ä½†æµªè´¹ CPUï¼›ä¸­æ–­ç­‰å¾…èŠ‚çœ CPU ä½†æœ‰ä¸­æ–­å¤„ç†å»¶è¿Ÿï¼›æ··åˆæ¨¡å¼ç»“åˆä¸¤è€…ä¼˜ç‚¹â€”â€”ROCm é»˜è®¤ä½¿ç”¨ã€‚GPU é€šè¿‡ IH Ringï¼ˆä¸­æ–­å¤„ç†ç¯å½¢ç¼“å†²åŒºï¼‰é€šçŸ¥ CPU ä¿¡å·é‡å˜åŒ–ã€‚',
          },
          codeWalk: {
            title: 'kfd_signal_event_handler â€” GPU ä¸­æ–­è§¦å‘äº‹ä»¶å”¤é†’',
            file: 'drivers/gpu/drm/amd/amdkfd/kfd_events.c',
            language: 'c',
            code: `/* kfd_events.c â€” KFD äº‹ä»¶ä¿¡å·å¤„ç† */

/* å½“ GPU å®Œæˆæ“ä½œå¹¶äº§ç”Ÿä¸­æ–­æ—¶è°ƒç”¨æ­¤å‡½æ•°
 * ç”± IH Ring å¤„ç†ç¨‹åº (kfd_interrupt_isr) åˆ†å‘
 *
 * data: ä¸­æ–­æºä¿¡æ¯ (signal event ID)
 */
void kfd_signal_event_handler(unsigned int client_id,
                              uint32_t event_id,
                              void *data)
{
    struct kfd_process *p;
    struct kfd_event *ev;

    /* é€šè¿‡ client_id (PASID) æŸ¥æ‰¾å¯¹åº”çš„è¿›ç¨‹ */
    p = kfd_lookup_process_by_pasid(client_id);
    if (!p)
        return;

    rcu_read_lock();

    /* åœ¨è¿›ç¨‹çš„äº‹ä»¶è¡¨ä¸­æŸ¥æ‰¾äº‹ä»¶
     * äº‹ä»¶è¡¨æ˜¯ IDR (ID Radix tree)ï¼ŒO(1) æŸ¥æ‰¾
     */
    ev = idr_find(&p->event_idr, event_id);
    if (!ev) {
        rcu_read_unlock();
        kfd_unref_process(p);
        return;
    }

    spin_lock(&ev->lock);

    /* æ ‡è®°äº‹ä»¶ä¸ºå·²è§¦å‘ */
    ev->signaled = true;
    ev->event_age++;

    /* å”¤é†’æ‰€æœ‰ç­‰å¾…åœ¨æ­¤äº‹ä»¶ä¸Šçš„çº¿ç¨‹
     * kfd_wait_on_event() ä¸­çš„ wait_event_interruptible_timeout
     * ä¼šæ£€æŸ¥ ev->signaled å¹¶è¿”å›
     */
    wake_up_all(&ev->wq);

    spin_unlock(&ev->lock);
    rcu_read_unlock();
    kfd_unref_process(p);
}

/* CPU ä¾§ç­‰å¾…äº‹ä»¶çš„æ ¸å¿ƒå‡½æ•° */
static int kfd_wait_on_event(struct kfd_process *p,
                             struct kfd_event *ev,
                             uint64_t timeout_ms)
{
    long timeout_jiffies;
    int ret;

    timeout_jiffies = msecs_to_jiffies(timeout_ms);

    /* ç­‰å¾…ç›´åˆ°äº‹ä»¶è¢«è§¦å‘æˆ–è¶…æ—¶
     * wait_event_interruptible_timeout å†…éƒ¨ï¼š
     *   1. å°†å½“å‰çº¿ç¨‹åŠ å…¥ ev->wq ç­‰å¾…é˜Ÿåˆ—
     *   2. è®¾ç½®çº¿ç¨‹çŠ¶æ€ä¸º TASK_INTERRUPTIBLE
     *   3. è°ƒç”¨ schedule() è®©å‡º CPU
     *   4. è¢« wake_up_all å”¤é†’åæ£€æŸ¥æ¡ä»¶
     */
    ret = wait_event_interruptible_timeout(
        ev->wq,
        ev->signaled,    /* å”¤é†’æ¡ä»¶ï¼šäº‹ä»¶å·²è§¦å‘ */
        timeout_jiffies);

    if (ret == 0)
        return -ETIME;   /* è¶…æ—¶ */
    if (ret < 0)
        return ret;       /* è¢«ä¿¡å·æ‰“æ–­ */

    /* é‡ç½®äº‹ä»¶çŠ¶æ€ï¼ˆone-shot è¯­ä¹‰ï¼‰*/
    spin_lock(&ev->lock);
    ev->signaled = false;
    spin_unlock(&ev->lock);

    return 0;
}`,
            annotations: [
              'kfd_signal_event_handler ç”± IH Ring å¤„ç†ç¨‹åºåˆ†å‘è°ƒç”¨â€”â€”å½“ GPU å†™å…¥ IH Ring è¡¨ç¤ºæ“ä½œå®Œæˆæ—¶',
              'client_id æ˜¯ PASIDâ€”â€”GPU åœ¨ä¸­æ–­æ•°æ®ä¸­æºå¸¦ PASID æ¥æ ‡è¯†æ˜¯å“ªä¸ªè¿›ç¨‹çš„äº‹ä»¶',
              'idr_find æ˜¯ O(1) çš„ ID æŸ¥æ‰¾ï¼Œäº‹ä»¶è¡¨ç”¨ IDRï¼ˆID Radix treeï¼‰å®ç°ä»¥æ”¯æŒå¿«é€ŸæŸ¥æ‰¾',
              'wake_up_all å”¤é†’æ‰€æœ‰ç­‰å¾…çº¿ç¨‹â€”â€”å¤šä¸ª CPU çº¿ç¨‹å¯ä»¥ç­‰å¾…åŒä¸€ä¸ªäº‹ä»¶',
              'wait_event_interruptible_timeout æ˜¯å†…æ ¸æ ‡å‡†çš„æ¡ä»¶ç­‰å¾…åŸè¯­â€”â€”çº¿ç¨‹ä¼‘çœ ç›´åˆ°æ¡ä»¶æ»¡è¶³',
              'one-shot è¯­ä¹‰ï¼šäº‹ä»¶è§¦å‘åé‡ç½® signaled=falseï¼Œä¸‹æ¬¡ç­‰å¾…éœ€è¦æ–°çš„ GPU å®Œæˆä¿¡å·',
            ],
            explanation: 'GPU å®Œæˆ kernel æ‰§è¡Œåçš„ä¸­æ–­å¤„ç†é“¾ï¼šGPU å°†ä¸­æ–­ä¿¡æ¯å†™å…¥ IH Ring â†’ amdgpu çš„ IH Ring å¤„ç†ç¨‹åºè¯»å–ä¸­æ–­ â†’ è¯†åˆ«å‡ºæ˜¯ KFD ä¿¡å·äº‹ä»¶ â†’ è°ƒç”¨ kfd_signal_event_handler â†’ æŸ¥æ‰¾è¿›ç¨‹å’Œäº‹ä»¶ â†’ å”¤é†’ç­‰å¾…çº¿ç¨‹ã€‚kfd_wait_on_event å¯¹åº”ç”¨æˆ·ç©ºé—´çš„ hsaKmtWaitOnEvent æˆ– hipDeviceSynchronize çš„åº•å±‚å®ç°ã€‚ç†è§£è¿™ä¸ªä¸­æ–­-å”¤é†’è·¯å¾„æ˜¯ç†è§£ CPU-GPU åŒæ­¥å»¶è¿Ÿçš„å…³é”®ã€‚',
          },
          miniLab: {
            title: 'æµ‹é‡ CPU-GPU åŒæ­¥å»¶è¿Ÿ',
            objective: 'ç¼–å†™ä¸€ä¸ªç®€å•çš„ HIP ç¨‹åºæµ‹é‡ä» GPU kernel å®Œæˆåˆ° CPU è¢«å”¤é†’çš„å»¶è¿Ÿï¼Œå¯¹æ¯”è½®è¯¢å’Œä¸­æ–­æ¨¡å¼ã€‚',
            setup: `# éœ€è¦ ROCm å’Œ HIP ç¼–è¯‘å™¨
# å¦‚æœæ²¡æœ‰ ROCmï¼Œå¯ä»¥é€šè¿‡ ftrace è§‚å¯Ÿ kfd_signal_event_handler`,
            steps: [
              'ç¼–å†™ HIP ç¨‹åºï¼šå¯åŠ¨ä¸€ä¸ªç©º kernelï¼Œç„¶åç”¨ hipEventElapsedTime æµ‹é‡åŒæ­¥å»¶è¿Ÿ',
              'è¿è¡Œ 100 æ¬¡å–å¹³å‡ï¼šè®°å½• hipDeviceSynchronize çš„è€—æ—¶',
              'ä½¿ç”¨ ftrace è¿½è¸ª kfd_signal_event_handlerï¼šecho kfd_signal_event_handler > /sys/kernel/debug/tracing/set_ftrace_filter',
              'å¯ç”¨å‡½æ•°è·Ÿè¸ªï¼šecho function > /sys/kernel/debug/tracing/current_tracer',
              'è¿è¡Œ HIP ç¨‹åºåæŸ¥çœ‹ traceï¼šcat /sys/kernel/debug/tracing/trace | grep kfd_signal',
              'è§‚å¯Ÿä¸­æ–­åˆ°å”¤é†’çš„æ—¶é—´å·®ï¼ˆtimestamp åˆ—ï¼‰',
            ],
            expectedOutput: `# HIP åŒæ­¥å»¶è¿Ÿæµ‹é‡
hipDeviceSynchronize average latency: ~5-15 Î¼s (ä¸­æ–­æ¨¡å¼)

# ftrace è¾“å‡º
$ cat /sys/kernel/debug/tracing/trace | grep kfd_signal
 amdgpu-12345  [002] 89.123456: kfd_signal_event_handler
               â† ä»ä¸­æ–­å‘ç”Ÿåˆ° handler æ‰§è¡Œ ~2-5Î¼s

å¯¹æ¯” hipStreamQuery (è½®è¯¢æ¨¡å¼):
average latency: ~1-3 Î¼s (æ›´ä½å»¶è¿Ÿä½†æ¶ˆè€— CPU)`,
            hint: 'å¦‚æœæ— æ³•å®‰è£… ROCmï¼Œå¯ä»¥é€šè¿‡é˜…è¯» kfd_events.c æºç ä¸­ wait_event_interruptible_timeout çš„ç”¨æ³•æ¥ç†è§£åŒæ­¥æœºåˆ¶ã€‚å…³æ³¨ ev->signaled çš„è®¾ç½®å’Œæ£€æŸ¥æ—¶æœºã€‚',
          },
          debugExercise: {
            title: 'è¯Šæ–­ CPU-GPU åŒæ­¥æ­»é”',
            language: 'c',
            description: 'ä¸€ä¸ªå¤šæµ HIP ç¨‹åºæŒ‚èµ·â€”â€”hipDeviceSynchronize æ°¸è¿œä¸è¿”å›ã€‚åˆ†æä»¥ä¸‹åœºæ™¯æ‰¾å‡ºåŸå› ã€‚',
            question: 'ä¸ºä»€ä¹ˆ hipDeviceSynchronize æ°¸è¿œä¸è¿”å›ï¼Ÿè¿™æ˜¯æ­»é”å—ï¼Ÿå¦‚ä½•ä¿®å¤ï¼Ÿ',
            buggyCode: `/* æœ‰é—®é¢˜çš„å¤šæµ HIP ç¨‹åº */
hipStream_t stream1, stream2;
hipStreamCreate(&stream1);
hipStreamCreate(&stream2);

/* åœ¨ stream1 ä¸Šå¯åŠ¨ kernel A */
kernelA<<<grid, block, 0, stream1>>>(data);

/* åœ¨ CPU ä¸Šç­‰å¾… stream1 å®Œæˆï¼ˆé˜»å¡!ï¼‰ */
hipStreamSynchronize(stream1);

/* BUG: kernelA å†…éƒ¨åœ¨ç­‰å¾… stream2 ä¸Šçš„ kernelB å®Œæˆ
 * ä½† kernelB è¿˜æ²¡æœ‰è¢«å¯åŠ¨ï¼
 */

/* è¿™è¡Œä»£ç æ°¸è¿œä¸ä¼šæ‰§è¡Œåˆ° */
kernelB<<<grid, block, 0, stream2>>>(data);
hipStreamSynchronize(stream2);

/* ----- dmesg è¾“å‡º ----- */
/* [120.5] [drm:amdgpu_job_timedout] *ERROR*
 *   ring comp_1.0.0 timeout,
 *   signaled seq=100, emitted seq=101
 * [120.5] amdgpu: GPU reset begin!
 */`,
            hint: 'kernelA åœ¨ç­‰å¾…ä¸€ä¸ªæ°¸è¿œä¸ä¼šè§¦å‘çš„ä¿¡å·â€”â€”å› ä¸ºäº§ç”Ÿè¯¥ä¿¡å·çš„ kernelB è¢«é˜»å¡åœ¨ CPU ä¾§ï¼ˆCPU åœ¨ hipStreamSynchronize ä¸­ç­‰å¾… kernelAï¼‰ã€‚',
            answer: 'è¿™æ˜¯ä¸€ä¸ªç»å…¸çš„ CPU-GPU æ­»é”åœºæ™¯ï¼šï¼ˆ1ï¼‰CPU åœ¨ hipStreamSynchronize(stream1) ä¸­ç­‰å¾… kernelA å®Œæˆï¼›ï¼ˆ2ï¼‰kernelA åœ¨ GPU ä¸Šæ‰§è¡Œæ—¶ï¼Œå†…éƒ¨é€šè¿‡ HSA ä¿¡å·é‡ç­‰å¾… stream2 ä¸Šçš„ kernelB å®Œæˆï¼›ï¼ˆ3ï¼‰ä½† kernelB çš„å¯åŠ¨ä»£ç åœ¨ CPU ä¸Šï¼Œä½äº hipStreamSynchronize ä¹‹åâ€”â€”CPU è¢«é˜»å¡å¯¼è‡´ kernelB æ°¸è¿œä¸ä¼šè¢«æäº¤åˆ° GPUã€‚å½¢æˆç¯å½¢ç­‰å¾…ï¼šCPU ç­‰ kernelA â†’ kernelA ç­‰ kernelB â†’ kernelB éœ€è¦ CPU æäº¤ã€‚æœ€ç»ˆ GPU çš„ amdgpu_job_timedout æ£€æµ‹åˆ°è¶…æ—¶ï¼Œè§¦å‘ GPU resetã€‚ä¿®å¤æ–¹æ³•ï¼šï¼ˆaï¼‰å…ˆæäº¤æ‰€æœ‰ kernel åˆ°å„è‡ªçš„ streamï¼Œç„¶åå†åŒæ­¥ï¼škernelA<<<...stream1>>>; kernelB<<<...stream2>>>; hipStreamSynchronize(stream1); hipStreamSynchronize(stream2);ï¼ˆbï¼‰ä½¿ç”¨ hipStreamWaitEvent å®ç° GPU ä¾§çš„ stream é—´ä¾èµ–ï¼Œè€Œä¸æ˜¯ CPU ä¾§çš„åŒæ­¥ï¼›ï¼ˆcï¼‰é¿å…åœ¨ GPU kernel å†…éƒ¨ç­‰å¾…å…¶ä»– stream çš„ä¿¡å·â€”â€”è¿™ç§æ¨¡å¼å®¹æ˜“å¯¼è‡´æ­»é”ã€‚',
          },
          interviewQ: {
            question: 'æè¿° KFD ä¸­ CPU-GPU åŒæ­¥çš„å®Œæ•´è·¯å¾„ï¼šä» GPU å®Œæˆä¸€ä¸ª kernel åˆ° CPU çº¿ç¨‹è¢«å”¤é†’ã€‚åŒ…æ‹¬ HSA ä¿¡å·é‡ã€IH Ringã€KFD äº‹ä»¶æœºåˆ¶å’Œå”¤é†’è¿‡ç¨‹ã€‚',
            difficulty: 'hard',
            hint: 'æŒ‰ç…§äº‹ä»¶é“¾ï¼šGPU åŸå­å†™ signal â†’ GPU å†™ IH Ring â†’ CPU ä¸­æ–­ â†’ IH handler â†’ kfd_signal_event_handler â†’ wake_up_all â†’ ç”¨æˆ·çº¿ç¨‹è¿”å›ã€‚',
            answer: 'å®Œæ•´åŒæ­¥è·¯å¾„ï¼šï¼ˆ1ï¼‰GPU çš„ Shader Engine æ‰§è¡Œå®Œ kernel çš„æœ€åä¸€ä¸ª workgroupï¼›ï¼ˆ2ï¼‰GPU çš„ CP å¯¹ AQL åŒ…ä¸­çš„ completion_signal åœ°å€æ‰§è¡Œ atomic_dec æ“ä½œï¼ˆ64 ä½åŸå­é€’å‡ï¼‰ï¼Œå°†ä¿¡å·é‡ä» 1 é€’å‡ä¸º 0ï¼›ï¼ˆ3ï¼‰å¦‚æœé€’å‡åçš„å€¼ä¸º 0 ä¸”è¯¥ä¿¡å·é‡å…³è”äº†ä¸­æ–­äº‹ä»¶ï¼ŒGPU å‘ IH Ringï¼ˆInterrupt Handler Ringï¼‰å†™å…¥ä¸€æ¡ä¸­æ–­æ¡ç›®ï¼ŒåŒ…å« source_idï¼ˆ146 = signal completionï¼‰ã€PASIDï¼ˆè¿›ç¨‹æ ‡è¯†ï¼‰å’Œ event_idï¼›ï¼ˆ4ï¼‰amdgpu çš„ IH Ring å¤„ç†ç¨‹åºï¼ˆamdgpu_irq_handlerï¼‰åœ¨ IRQ ä¸Šä¸‹æ–‡ä¸­è¯»å– IH Ringï¼Œè¯†åˆ«å‡ºè¿™æ˜¯ KFD ä¿¡å·äº‹ä»¶ï¼Œè°ƒç”¨ kfd_interrupt_isr å°†äº‹ä»¶åŠ å…¥ KFD çš„ä¸­æ–­å·¥ä½œé˜Ÿåˆ—ï¼›ï¼ˆ5ï¼‰KFD çš„ä¸­æ–­å·¥ä½œçº¿ç¨‹è°ƒç”¨ kfd_signal_event_handlerï¼Œé€šè¿‡ PASID æ‰¾åˆ°è¿›ç¨‹çš„ kfd_processï¼Œé€šè¿‡ event_id åœ¨ IDR ä¸­æ‰¾åˆ° kfd_eventï¼›ï¼ˆ6ï¼‰è®¾ç½® ev->signaled = trueï¼Œè°ƒç”¨ wake_up_all(&ev->wq) å”¤é†’ç­‰å¾…é˜Ÿåˆ—ä¸Šçš„æ‰€æœ‰çº¿ç¨‹ï¼›ï¼ˆ7ï¼‰ç”¨æˆ·çº¿ç¨‹ä» wait_event_interruptible_timeout è¿”å›ï¼Œkfd_wait_on_event è¿”å› 0 è¡¨ç¤ºæˆåŠŸï¼›ï¼ˆ8ï¼‰ç”¨æˆ·ç©ºé—´çš„ hipDeviceSynchronize è¿”å›ã€‚æ•´ä¸ªè·¯å¾„å»¶è¿Ÿçº¦ 5-15Î¼sï¼Œä¸»è¦å¼€é”€åœ¨ä¸­æ–­å¤„ç†å’Œçº¿ç¨‹è°ƒåº¦ã€‚å¯¹æ¯”è½®è¯¢æ¨¡å¼ï¼šCPU ç›´æ¥è¯»å–ä¿¡å·é‡å†…å­˜ä½ç½®ï¼Œå»¶è¿Ÿ ~100ns-1Î¼sï¼Œä½†å ç”¨ CPU æ ¸å¿ƒã€‚ROCm é»˜è®¤ä½¿ç”¨æ··åˆç­–ç•¥â€”â€”å…ˆçŸ­æš‚è½®è¯¢ï¼Œç„¶ååˆ‡æ¢åˆ°ä¸­æ–­ç­‰å¾…ã€‚',
            amdContext: 'èƒ½è¯¦ç»†æè¿°è¿™æ¡ä¸­æ–­-å”¤é†’è·¯å¾„è¯´æ˜ä½ æ·±å…¥ç†è§£äº† KFD çš„å®ç°ç»†èŠ‚ã€‚AMD é¢è¯•ä¸­æåˆ° IH Ringã€PASID æŸ¥æ‰¾å’Œ wake_up_all è¿™äº›å…·ä½“æœºåˆ¶ä¼šå±•ç¤ºä½ ä¸ä»…ç†è§£æ¦‚å¿µï¼Œè¿˜é˜…è¯»è¿‡å®é™…ä»£ç ã€‚é¢å¤–åŠ åˆ†é¡¹ï¼šæåˆ° ROCm çš„æ··åˆè½®è¯¢/ä¸­æ–­ç­–ç•¥ä½“ç°äº†å·¥ç¨‹å®è·µæ„è¯†ã€‚',
          },
        },
      ],
    },
  ],
  completionChecklist: [
    'ç†è§£ HSA æ¶æ„çš„æ ¸å¿ƒç†å¿µâ€”â€”CPU/GPU ä½œä¸ºå¹³ç­‰çš„è®¡ç®—ä»£ç†å…±äº«è™šæ‹Ÿåœ°å€ç©ºé—´',
    'èƒ½è§£é‡Š KFD ä¸ DRM æ¥å£çš„åŒºåˆ«ï¼ˆå‘½ä»¤æ ¼å¼ã€é˜Ÿåˆ—æ¨¡å‹ã€å†…å­˜æ¨¡å‹ï¼‰',
    'ç†è§£ AQL åŒ…çš„ 64 å­—èŠ‚ç»“æ„å’Œç”¨æˆ·æ€é˜Ÿåˆ—çš„é›¶å†…æ ¸æäº¤è·¯å¾„',
    'èƒ½æè¿° MQD/HQD æ˜ å°„æœºåˆ¶å’Œ doorbell é©±åŠ¨çš„é˜Ÿåˆ—é€šçŸ¥',
    'ç†è§£ SVM çš„å®ç°ï¼šGPUVM é¡µè¡¨ã€PASIDã€GPU page faultã€é¡µé¢è¿ç§»',
    'èƒ½è§£é‡Š svm_range æ•°æ®ç»“æ„å’Œ svm_migrate_to_vram/ram çš„è¿ç§»æµç¨‹',
    'ç†è§£ HSA ä¿¡å·é‡ï¼ˆ64 ä½åŸå­è®¡æ•°å™¨ï¼‰å’Œ KFD äº‹ä»¶ï¼ˆä¸­æ–­é©±åŠ¨å”¤é†’ï¼‰çš„å·¥ä½œæœºåˆ¶',
    'èƒ½æè¿°ä» GPU kernel å®Œæˆåˆ° CPU çº¿ç¨‹å”¤é†’çš„å®Œæ•´ä¸­æ–­è·¯å¾„',
  ],
};

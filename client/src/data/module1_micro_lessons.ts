// ============================================================
// AMD Linux Driver Learning Platform - Module 1 Micro-Lessons
// Module 1: Prerequisites (基础准备)
// Auto-generated by gen_module1.py
// ============================================================
import type { MicroLessonModule } from './micro_lesson_types';

export const module1MicroLessons: MicroLessonModule = {
  moduleId: 'prerequisites',
  groups: [
    {
      id: "1-1",
      number: "1.1",
      title: "C \u5185\u5b58\u6a21\u578b",
      titleEn: "C Memory Model",
      icon: "\ud83e\udde0",
      description: "\u9a71\u52a8\u5f00\u53d1\u7684\u57fa\u77f3\u3002\u7406\u89e3\u6307\u9488\u3001\u7ed3\u6784\u4f53\u5e03\u5c40\u548c\u4f4d\u64cd\u4f5c\uff0c\u662f\u8bfb\u61c2\u4efb\u4f55\u5185\u6838\u4ee3\u7801\u7684\u524d\u63d0\u3002",
      lessons: [
        {
          id: "1-1-1",
          number: "1.1.1",
          title: "\u6307\u9488\u7b97\u672f\u4e0e\u5185\u5b58\u6a21\u578b",
          titleEn: "Pointer Arithmetic & Memory Model",
          duration: 15,
          tags: ["C", "pointer", "memory"],
          concept: {
            summary: "\u6307\u9488\u662f\u5185\u5b58\u5730\u5740\u7684\u6570\u5b57\u8868\u793a\uff0c\u6307\u9488\u7b97\u672f\u662f\u6309\u7c7b\u578b\u5927\u5c0f\u6b65\u8fdb\u7684\u5730\u5740\u8fd0\u7b97\u3002",
            explanation: [
              "在 C 语言中，指针本质上是一个整数，存储的是内存地址。当你写 int *p = &x 时，p 存储的是变量 x 在内存中的地址（一个 64 位数字，如 0xFFFF888001234560）。",
              "指针算术的关键规则：p + 1 不是地址加 1，而是地址加 sizeof(*p)。如果 p 是 int*，p + 1 就是地址加 4（因为 int 是 4 字节）。如果 p 是 struct amdgpu_ring*，p + 1 就是地址加整个结构体的大小。",
              "在内核驱动中，指针算术无处不在。例如，当驱动需要访问 GPU 寄存器时，会将 BAR（Base Address Register）映射到一个 void __iomem * 指针，然后通过偏移量访问不同的寄存器。理解这个机制是读懂 amdgpu 寄存器访问代码的基础。",
              "一个常见的内核模式是 container_of 宏：给定一个结构体成员的指针，通过指针算术反推出包含它的结构体的指针。这在 Linux 内核的链表和对象系统中被大量使用。"
],
            keyPoints: [
              "p + n 等价于 (char*)p + n * sizeof(*p)",
              "void* 指针不能直接做算术，需要先转型",
              "内核中 __iomem 标注的指针必须用 readl/writel 访问，不能直接解引用",
              "container_of(ptr, type, member) 是内核最重要的宏之一"
],
          },
          diagram: {
            title: "\u5185\u5b58\u4e2d\u7684\u6307\u9488\u4e0e\u6570\u7ec4",
            content: `地址:    0x100    0x104    0x108    0x10C    0x110
         +--------+--------+--------+--------+--------+
内存:    |  0x0A  |  0x14  |  0x1E  |  0x28  |  0x32  |
         +--------+--------+--------+--------+--------+
           ^
           p (int*, 指向 0x100)

p[0] = *(p+0) -> 地址 0x100 -> 值 0x0A (10)
p[1] = *(p+1) -> 地址 0x104 -> 值 0x14 (20)  <- +4字节(sizeof int)
p[2] = *(p+2) -> 地址 0x108 -> 值 0x1E (30)

container_of 示例:
struct amdgpu_ring {
    ...
    struct drm_gpu_scheduler sched;  <- 偏移量: 假设 128 字节
    ...
};
给定 &ring->sched，container_of 会减去 128 字节得到 ring 的地址`,
            caption: "int \u6570\u7ec4\u7684\u5185\u5b58\u5e03\u5c40\u3002\u6bcf\u4e2a\u5143\u7d20\u5360 4 \u5b57\u8282\uff0cp+1 \u8df3\u8fc7 4 \u5b57\u8282\u800c\u975e 1 \u5b57\u8282\u3002",
          },
          codeWalk: {
            title: "container_of \u5b8f \u2014 \u5185\u6838\u4e2d\u6700\u91cd\u8981\u7684\u6307\u9488\u6280\u5de7",
            file: "include/linux/container_of.h",
            language: "c",
            code: `/* include/linux/container_of.h */
#define container_of(ptr, type, member) ({          \\
    void *__mptr = (void *)(ptr);                   \\ /* 1 */
    static_assert(__same_type(*(ptr),               \\
        ((type *)0)->member),                       \\ /* 2 */
        "pointer type mismatch in container_of()"); \\
    ((type *)(__mptr - offsetof(type, member))); }) /* 3 */

/* 使用示例 — 在 amdgpu_sched.c 中 */
static struct amdgpu_ring *
to_amdgpu_ring(struct drm_gpu_scheduler *sched)
{
    return container_of(sched, struct amdgpu_ring, sched); /* 4 */
}`,
            annotations: [
              "将 ptr 转为 void* 避免编译器警告",
              "编译时类型检查：确保 ptr 的类型与 type.member 的类型匹配",
              "核心计算：用 offsetof 获取 member 在 type 中的偏移量，然后从 ptr 地址减去这个偏移量，得到包含结构体的起始地址",
              "实际应用：给定 drm_gpu_scheduler 指针，反推出包含它的 amdgpu_ring 结构体指针"
],
            explanation: "container_of \u662f Linux \u5185\u6838\u5b9e\u73b0\u9762\u5411\u5bf9\u8c61\u591a\u6001\u7684\u6838\u5fc3\u673a\u5236\u3002DRM \u8c03\u5ea6\u5668\u53ea\u77e5\u9053 drm_gpu_scheduler\uff0c\u4f46\u901a\u8fc7 container_of\uff0camdgpu \u9a71\u52a8\u53ef\u4ee5\u4ece\u901a\u7528\u8c03\u5ea6\u5668\u6307\u9488\u83b7\u53d6\u5230 amdgpu_ring \u7684\u5b8c\u6574\u4fe1\u606f\u3002\u8fd9\u79cd\u6a21\u5f0f\u5728\u6574\u4e2a\u5185\u6838\u4e2d\u968f\u5904\u53ef\u89c1\u3002",
          },
          miniLab: {
            title: "\u5b9e\u73b0\u4f60\u81ea\u5df1\u7684 container_of",
            objective: "\u7406\u89e3 offsetof \u548c\u6307\u9488\u7b97\u672f\uff0c\u624b\u52a8\u5b9e\u73b0 container_of \u7684\u529f\u80fd",
            setup: "mkdir -p ~/amd-labs/1-1-1 && cd ~/amd-labs/1-1-1",
            language: "c",
            code: `#include <stdio.h>
#include <stddef.h>

struct amdgpu_ring {
    int ring_id;
    char name[32];
    int wptr;
    int rptr;
    struct {
        int timeout;
        int hw_submission;
    } sched;
    int num_dw;
};

#define my_container_of(ptr, type, member) \\
    ((type *)((char *)(ptr) - offsetof(type, member)))

int main() {
    struct amdgpu_ring ring = {
        .ring_id = 42,
        .sched = { .timeout = 5000, .hw_submission = 64 }
    };
    void *sched_ptr = &ring.sched;
    struct amdgpu_ring *recovered = my_container_of(
        sched_ptr, struct amdgpu_ring, sched);
    printf("Original ring_id: %d\\n", ring.ring_id);
    printf("Recovered ring_id: %d\\n", recovered->ring_id);
    printf("Match: %s\\n",
        (&ring == recovered) ? "YES" : "NO");
    printf("offsetof(amdgpu_ring, sched) = %zu bytes\\n",
        offsetof(struct amdgpu_ring, sched));
    return 0;
}`,
            steps: [
              "将上面的代码保存为 lab.c",
              "编译：gcc -o lab lab.c && ./lab",
              "观察输出，确认 ring_id 匹配",
              "修改结构体，在 sched 前添加更多字段，观察 offsetof 的变化",
              "尝试用 __attribute__((packed)) 修饰结构体，观察 offsetof 的变化"
],
            expectedOutput: `Original ring_id: 42
Recovered ring_id: 42
Match: YES
offsetof(amdgpu_ring, sched) = 36 bytes`,
            hint: "offsetof(type, member) \u8fd4\u56de member \u5728 type \u7ed3\u6784\u4f53\u4e2d\u7684\u5b57\u8282\u504f\u79fb\u91cf\u3002\u4ece member \u7684\u5730\u5740\u51cf\u53bb\u8fd9\u4e2a\u504f\u79fb\u91cf\uff0c\u5c31\u5f97\u5230\u4e86\u7ed3\u6784\u4f53\u7684\u8d77\u59cb\u5730\u5740\u3002",
          },
          debugExercise: {
            title: "\u627e\u51fa\u8fd9\u6bb5\u4ee3\u7801\u4e2d\u7684 Bug",
            description: "\u4e0b\u9762\u7684\u4ee3\u7801\u8bd5\u56fe\u904d\u5386\u4e00\u4e2a GPU \u5bc4\u5b58\u5668\u6570\u7ec4\uff0c\u4f46\u7ed3\u679c\u4e0d\u6b63\u786e\u3002\u627e\u51fa\u95ee\u9898\u6240\u5728\u3002",
            buggyCode: `#include <stdio.h>
#include <stdint.h>

uint32_t fake_bar[16] = {
    0x100, 0x200, 0x300, 0x400,
};

void read_registers(void *base, int count) {
    char *p = (char *)base;
    for (int i = 0; i < count; i++) {
        /* BUG: 试图读取每个 uint32_t 寄存器 */
        printf("REG[%d] = 0x%X\\n", i, *(uint32_t *)(p + i));
    }
}

int main() {
    read_registers(fake_bar, 4);
    return 0;
}`,
            language: "c",
            question: "\u8fd9\u6bb5\u4ee3\u7801\u6709\u4ec0\u4e48\u95ee\u9898\uff1f\u4f1a\u5bfc\u81f4\u4ec0\u4e48\u540e\u679c\uff1f",
            hint: "\u6bcf\u4e2a uint32_t \u5360 4 \u5b57\u8282\uff0c\u6240\u4ee5\u504f\u79fb\u91cf\u5e94\u8be5\u662f i * sizeof(uint32_t) \u800c\u4e0d\u662f i\u3002",
            answer: "\u5c06 p + i \u6539\u4e3a p + i * sizeof(uint32_t)\uff0c\u6216\u8005\u76f4\u63a5\u5c06 p \u58f0\u660e\u4e3a uint32_t *p \u7136\u540e\u7528 p[i] \u8bbf\u95ee\u3002\u5728\u5185\u6838\u9a71\u52a8\u4e2d\uff0c\u8fd9\u7c7b\u9519\u8bef\u4f1a\u5bfc\u81f4\u8bfb\u53d6\u9519\u8bef\u7684\u5bc4\u5b58\u5668\u5730\u5740\uff0c\u5f15\u53d1 GPU \u5f02\u5e38\u3002",
          },
          interviewQ: {
            question: "\u5728 Linux \u5185\u6838\u9a71\u52a8\u4e2d\uff0c\u4e3a\u4ec0\u4e48\u4e0d\u80fd\u76f4\u63a5\u89e3\u5f15\u7528 __iomem \u6307\u9488\uff0c\u800c\u5fc5\u987b\u4f7f\u7528 readl()/writel() \u51fd\u6570\uff1f",
            difficulty: "medium",
            hint: "\u8003\u8651\u5185\u5b58\u5c4f\u969c\uff08memory barrier\uff09\u548c\u7f16\u8bd1\u5668\u4f18\u5316\u7684\u95ee\u9898\u3002",
            answer: "__iomem \u6307\u9488\u6307\u5411\u7684\u662f MMIO\uff08Memory-Mapped I/O\uff09\u533a\u57df\uff0c\u5373 GPU \u5bc4\u5b58\u5668\u7a7a\u95f4\u3002\u76f4\u63a5\u89e3\u5f15\u7528\u5b58\u5728\u4e24\u4e2a\u95ee\u9898\uff1a1\uff09\u7f16\u8bd1\u5668\u53ef\u80fd\u5bf9\u5185\u5b58\u8bbf\u95ee\u8fdb\u884c\u91cd\u6392\u5e8f\u4f18\u5316\uff0c\u800c GPU \u5bc4\u5b58\u5668\u7684\u8bbf\u95ee\u987a\u5e8f\u901a\u5e38\u6709\u4e25\u683c\u8981\u6c42\uff1b2\uff09\u5728\u67d0\u4e9b\u67b6\u6784\u4e0a\uff0cMMIO \u8bbf\u95ee\u9700\u8981\u7279\u6b8a\u7684 CPU \u6307\u4ee4\u6765\u4fdd\u8bc1\u8bbf\u95ee\u7684\u539f\u5b50\u6027\u548c\u987a\u5e8f\u6027\u3002readl()/writel() \u5185\u90e8\u5305\u542b\u4e86\u5fc5\u8981\u7684\u5185\u5b58\u5c4f\u969c\uff08mb()\uff09\uff0c\u786e\u4fdd\u8bbf\u95ee\u987a\u5e8f\u6b63\u786e\u3002",
            amdContext: "amdgpu \u9a71\u52a8\u4e2d\u5927\u91cf\u4f7f\u7528 RREG32()/WREG32() \u5b8f\uff0c\u5b83\u4eec\u6700\u7ec8\u8c03\u7528 readl()/writel()\u3002AMD \u9762\u8bd5\u4e2d\u7ecf\u5e38\u95ee\u5230 MMIO \u8bbf\u95ee\u7684\u6b63\u786e\u65b9\u5f0f\u3002",
          },
        },
        {
          id: "1-1-2",
          number: "1.1.2",
          title: "\u7ed3\u6784\u4f53\u5185\u5b58\u5e03\u5c40\u4e0e\u5bf9\u9f50",
          titleEn: "Struct Layout & Alignment",
          duration: 15,
          tags: ["C", "struct", "alignment", "padding"],
          concept: {
            summary: "\u7f16\u8bd1\u5668\u4f1a\u5728\u7ed3\u6784\u4f53\u6210\u5458\u4e4b\u95f4\u63d2\u5165\u586b\u5145\u5b57\u8282\uff08padding\uff09\u4ee5\u6ee1\u8db3\u5bf9\u9f50\u8981\u6c42\uff0c\u8fd9\u76f4\u63a5\u5f71\u54cd\u9a71\u52a8\u7684\u5185\u5b58\u4f7f\u7528\u548c DMA \u64cd\u4f5c\u3002",
            explanation: [
              "CPU 访问内存时有对齐要求：4 字节的 int 必须存放在 4 的倍数地址，8 字节的 long 必须存放在 8 的倍数地址。如果不满足对齐，某些 CPU 会产生硬件异常，另一些则会用多次内存访问来完成，导致性能下降。",
              "为了满足对齐要求，编译器会在结构体成员之间自动插入填充字节（padding）。例如，struct { char a; int b; } 中，a 占 1 字节，但 b 需要 4 字节对齐，所以编译器会在 a 和 b 之间插入 3 字节的 padding，使整个结构体大小变为 8 字节而非 5 字节。",
              "在内核驱动开发中，结构体布局至关重要。当 CPU 通过 DMA 将数据传输给 GPU 时，GPU 期望看到特定的内存布局。如果驱动定义的结构体与 GPU 硬件期望的布局不匹配，就会导致 GPU 解析数据错误，产生难以调试的 bug。",
              "解决方案有两种：1）精心排列结构体成员，将大成员放在前面，避免 padding（推荐）；2）使用 __attribute__((packed)) 强制取消 padding，但这会导致非对齐访问，在某些架构上有性能损失。"
],
            keyPoints: [
              "结构体的对齐要求等于其最大成员的对齐要求",
              "成员声明顺序影响 padding 大小：大成员优先可以减少 padding",
              "sizeof(struct) 可能大于所有成员大小之和",
              "DMA 描述符结构体必须精确匹配硬件规格，不能有意外 padding"
],
          },
          diagram: {
            title: "\u7ed3\u6784\u4f53\u5185\u5b58\u5e03\u5c40\u5bf9\u6bd4",
            content: `// 糟糕的布局（8 字节 padding）
struct bad_layout {
    char  a;    // 1 byte  @ offset 0
                // 3 bytes padding
    int   b;    // 4 bytes @ offset 4
    char  c;    // 1 byte  @ offset 8
                // 7 bytes padding
    long  d;    // 8 bytes @ offset 16
};              // total: 24 bytes!

内存: [a][P][P][P][b][b][b][b][c][P][P][P][P][P][P][P][d][d][d][d][d][d][d][d]
       0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16 ...  23

// 优化的布局（2 字节 padding）
struct good_layout {
    long  d;    // 8 bytes @ offset 0
    int   b;    // 4 bytes @ offset 8
    char  a;    // 1 byte  @ offset 12
    char  c;    // 1 byte  @ offset 13
                // 2 bytes padding (结构体末尾对齐)
};              // total: 16 bytes (节省 8 字节!)`,
            caption: "\u901a\u8fc7\u91cd\u65b0\u6392\u5217\u6210\u5458\u987a\u5e8f\uff0c\u53ef\u4ee5\u5c06\u7ed3\u6784\u4f53\u4ece 24 \u5b57\u8282\u7f29\u5c0f\u5230 16 \u5b57\u8282\uff0c\u8282\u7701 33% \u7684\u5185\u5b58\u3002",
          },
          codeWalk: {
            title: "amdgpu_ib \u7ed3\u6784\u4f53 \u2014 GPU \u547d\u4ee4\u7f13\u51b2\u533a\u63cf\u8ff0\u7b26",
            file: "drivers/gpu/drm/amd/amdgpu/amdgpu.h",
            language: "c",
            code: `/* drivers/gpu/drm/amd/amdgpu/amdgpu.h */
struct amdgpu_ib {
    struct amdgpu_sa_bo     *sa_bo;    /* 1: 8 bytes - 指针，8字节对齐 */
    uint32_t                length_dw; /* 2: 4 bytes - 命令长度（以DW计）*/
    uint64_t                gpu_addr;  /* 3: 8 bytes - GPU虚拟地址 */
    uint32_t                *ptr;      /* 4: 8 bytes - CPU虚拟地址 */
    uint32_t                flags;     /* 5: 4 bytes - 标志位 */
};

/* 对比：如果顺序错误会怎样 */
struct amdgpu_ib_bad {
    uint32_t    flags;     /* 4 bytes @ 0 */
                           /* 4 bytes padding! */
    uint64_t    gpu_addr;  /* 8 bytes @ 8 */
    uint32_t    length_dw; /* 4 bytes @ 16 */
                           /* 4 bytes padding! */
    uint32_t    *ptr;      /* 8 bytes @ 24 */
};`,
            annotations: [
              "sa_bo 是指针（8字节），放在最前面满足8字节对齐",
              "length_dw 是 uint32_t（4字节），跟在 8 字节指针后，偏移量为 8",
              "gpu_addr 是 uint64_t（8字节），需要 8 字节对齐",
              "ptr 是指针（8字节），偏移量为 24",
              "flags 是 uint32_t（4字节），偏移量为 32"
],
            explanation: "amdgpu_ib \u63cf\u8ff0\u4e86\u4e00\u4e2a GPU \u547d\u4ee4\u7f13\u51b2\u533a\uff08Indirect Buffer\uff09\u3002\u8fd9\u4e2a\u7ed3\u6784\u4f53\u4f1a\u88ab\u5927\u91cf\u5206\u914d\u548c\u91ca\u653e\uff0c\u5408\u7406\u7684\u5185\u5b58\u5e03\u5c40\u53ef\u4ee5\u51cf\u5c11\u7f13\u5b58\u884c\u5360\u7528\uff0c\u63d0\u5347\u6027\u80fd\u3002\u5728\u5b9e\u9645\u7684\u5185\u6838\u4ee3\u7801\u4e2d\uff0c\u4f60\u4f1a\u770b\u5230\u5f00\u53d1\u8005\u975e\u5e38\u6ce8\u610f\u7ed3\u6784\u4f53\u7684\u6210\u5458\u987a\u5e8f\u3002",
          },
          miniLab: {
            title: "\u7ed3\u6784\u4f53\u5e03\u5c40\u5206\u6790\u5668",
            objective: "\u7528 C \u7a0b\u5e8f\u6253\u5370\u7ed3\u6784\u4f53\u7684\u5b8c\u6574\u5185\u5b58\u5e03\u5c40\uff0c\u7406\u89e3 padding \u7684\u4f4d\u7f6e\u548c\u5927\u5c0f",
            setup: "mkdir -p ~/amd-labs/1-1-2 && cd ~/amd-labs/1-1-2",
            language: "c",
            code: `#include <stdio.h>
#include <stddef.h>
#include <stdint.h>

struct layout_a { char a; int b; char c; long d; };
struct layout_b { long d; int b; char a; char c; };

struct gpu_dma_desc {
    uint64_t src_addr;
    uint64_t dst_addr;
    uint32_t size;
    uint32_t flags;
};

#define PRINT_FIELD(s, f) \\
    printf("  %-12s offset=%2zu  size=%zu\\n", \\
        #f, offsetof(s, f), sizeof(((s*)0)->f))

int main() {
    printf("=== layout_a ===\\nTotal: %zu bytes\\n", sizeof(struct layout_a));
    PRINT_FIELD(struct layout_a, a);
    PRINT_FIELD(struct layout_a, b);
    PRINT_FIELD(struct layout_a, c);
    PRINT_FIELD(struct layout_a, d);

    printf("\\n=== layout_b ===\\nTotal: %zu bytes\\n", sizeof(struct layout_b));
    PRINT_FIELD(struct layout_b, d);
    PRINT_FIELD(struct layout_b, b);
    PRINT_FIELD(struct layout_b, a);
    PRINT_FIELD(struct layout_b, c);

    printf("\\n=== gpu_dma_desc ===\\nTotal: %zu bytes\\n", sizeof(struct gpu_dma_desc));
    PRINT_FIELD(struct gpu_dma_desc, src_addr);
    PRINT_FIELD(struct gpu_dma_desc, dst_addr);
    PRINT_FIELD(struct gpu_dma_desc, size);
    PRINT_FIELD(struct gpu_dma_desc, flags);
    return 0;
}`,
            steps: [
              "保存为 lab.c，编译运行：gcc -o lab lab.c && ./lab",
              "观察 layout_a 和 layout_b 的 padding 差异",
              "计算 layout_a 浪费了多少字节",
              "思考：如果 gpu_dma_desc 有 padding，会发生什么？",
              "挑战：设计一个 0 padding 的结构体，包含 1 个 long、2 个 int、3 个 char"
],
            expectedOutput: `=== layout_a ===
Total: 24 bytes
  a            offset= 0  size=1
  b            offset= 4  size=4
  c            offset= 8  size=1
  d            offset=16  size=8

=== layout_b ===
Total: 16 bytes
  d            offset= 0  size=8
  b            offset= 8  size=4
  a            offset=12  size=1
  c            offset=13  size=1`,
            hint: "\u7ed3\u6784\u4f53\u672b\u5c3e\u4e5f\u53ef\u80fd\u6709 padding\uff0c\u4ee5\u786e\u4fdd\u7ed3\u6784\u4f53\u6570\u7ec4\u4e2d\u6bcf\u4e2a\u5143\u7d20\u90fd\u6ee1\u8db3\u5bf9\u9f50\u8981\u6c42\u3002",
          },
          debugExercise: {
            title: "\u627e\u51fa\u8fd9\u6bb5\u4ee3\u7801\u4e2d\u7684 Bug",
            description: "\u4e0b\u9762\u7684\u4ee3\u7801\u5b9a\u4e49\u4e86\u4e00\u4e2a GPU DMA \u63cf\u8ff0\u7b26\uff0c\u4f46\u5728 64 \u4f4d\u7cfb\u7edf\u4e0a\u4f1a\u4ea7\u751f\u610f\u5916\u7684 padding\uff0c\u5bfc\u81f4\u9a71\u52a8\u4e0e\u786c\u4ef6\u4e0d\u5339\u914d\u3002",
            buggyCode: `struct sdma_v4_packet_bad {
    uint32_t    op_sub_op;
    uint64_t    src_addr;    /* BUG: 这里会有 padding! */
    uint32_t    count;
    uint64_t    dst_addr;
};`,
            language: "c",
            question: "\u8fd9\u6bb5\u4ee3\u7801\u6709\u4ec0\u4e48\u95ee\u9898\uff1f\u4f1a\u5bfc\u81f4\u4ec0\u4e48\u540e\u679c\uff1f",
            hint: "uint64_t \u9700\u8981 8 \u5b57\u8282\u5bf9\u9f50\u3002op_sub_op\uff084\u5b57\u8282\uff09\u4e4b\u540e\uff0c\u7f16\u8bd1\u5668\u9700\u8981\u63d2\u5165 4 \u5b57\u8282 padding \u624d\u80fd\u8ba9 src_addr \u5bf9\u9f50\u5230 8 \u5b57\u8282\u8fb9\u754c\u3002",
            answer: "sdma_v4_packet_bad \u5927\u5c0f\u4e3a 32 \u5b57\u8282\uff08\u4e0d\u662f 24 \u5b57\u8282\uff09\uff1aop_sub_op(4) + padding(4) + src_addr(8) + count(4) + padding(4) + dst_addr(8) = 32\u3002\u8fd9\u4f1a\u5bfc\u81f4\u9a71\u52a8\u5199\u5165 GPU \u7684\u547d\u4ee4\u683c\u5f0f\u4e0e\u786c\u4ef6\u671f\u671b\u7684\u4e0d\u5339\u914d\uff0cGPU \u4f1a\u89e3\u6790\u9519\u8bef\u7684\u5730\u5740\uff0c\u8f7b\u5219\u547d\u4ee4\u5931\u8d25\uff0c\u91cd\u5219 GPU hang \u751a\u81f3\u7cfb\u7edf\u5d29\u6e83\u3002",
          },
          interviewQ: {
            question: "\u5728\u7f16\u5199 GPU DMA \u63cf\u8ff0\u7b26\u7ed3\u6784\u4f53\u65f6\uff0c\u4f60\u5982\u4f55\u786e\u4fdd\u6ca1\u6709\u610f\u5916\u7684 padding\uff1f\u8bf7\u7ed9\u51fa\u81f3\u5c11\u4e24\u79cd\u65b9\u6cd5\u3002",
            difficulty: "medium",
            hint: "\u8003\u8651\u7f16\u8bd1\u65f6\u68c0\u67e5\u548c\u8fd0\u884c\u65f6\u68c0\u67e5\u4e24\u79cd\u65b9\u5f0f\u3002",
            answer: "1\uff09\u4f7f\u7528 BUILD_BUG_ON(sizeof(struct foo) != expected_size) \u8fdb\u884c\u7f16\u8bd1\u65f6\u68c0\u67e5\uff1b2\uff09\u4f7f\u7528 static_assert \u5728 C11 \u4e2d\uff1b3\uff09\u4f7f\u7528 __attribute__((packed)) \u6d88\u9664 padding\uff1b4\uff09\u6309\u7167\u4ece\u5927\u5230\u5c0f\u7684\u987a\u5e8f\u6392\u5217\u6210\u5458\uff1b5\uff09\u7528 pahole \u5de5\u5177\u5206\u6790\u7ed3\u6784\u4f53\u5e03\u5c40\u3002",
            amdContext: "SDMA \u547d\u4ee4\u5305\u7684\u7ed3\u6784\u4f53\u5fc5\u987b\u7cbe\u786e\u5339\u914d AMD \u786c\u4ef6\u624b\u518c\u4e2d\u7684\u89c4\u683c\u3002amdgpu \u9a71\u52a8\u4e2d\u6709\u5927\u91cf BUILD_BUG_ON \u68c0\u67e5\uff0c\u786e\u4fdd\u8fd9\u4e9b\u7ed3\u6784\u4f53\u7684\u5927\u5c0f\u6b63\u786e\u3002",
          },
        },
        {
          id: "1-1-3",
          number: "1.1.3",
          title: "\u4f4d\u64cd\u4f5c\u4e0e\u5bc4\u5b58\u5668\u8bbf\u95ee",
          titleEn: "Bit Operations & Register Access",
          duration: 15,
          tags: ["C", "bitops", "registers", "bitmask"],
          concept: {
            summary: "GPU \u5bc4\u5b58\u5668\u662f\u4f4d\u57df\uff08bit fields\uff09\u7684\u96c6\u5408\uff0c\u4f4d\u64cd\u4f5c\u662f\u9a71\u52a8\u4e0e\u786c\u4ef6\u901a\u4fe1\u7684\u57fa\u672c\u8bed\u8a00\u3002",
            explanation: [
              "GPU 寄存器是一个 32 位或 64 位的整数，其中每个位或每组位代表不同的硬件状态或控制信号。例如，一个 32 位的 GPU 状态寄存器可能用第 0 位表示 GPU 忙碌，第 1-4 位表示当前功耗状态，第 5-8 位表示温度警告级别等。",
              "驱动需要精确地读取和修改这些位，而不影响其他位。这就是位操作的核心用途。常用的操作包括：用 |= 设置某位（set bit）、用 &= ~mask 清除某位（clear bit）、用 & 读取某位（test bit）、用 ^= 翻转某位（toggle bit）。",
              "在 amdgpu 驱动中，你会看到大量类似 RREG32_SOC15(GC, 0, mmGRBM_STATUS) 的代码，这些宏读取 GPU 寄存器，然后用位掩码（bitmask）提取特定字段。",
              "内核提供了一套标准的位操作 API：set_bit()、clear_bit()、test_bit()、test_and_set_bit() 等。这些函数是原子操作，可以安全地在并发环境中使用。"
],
            keyPoints: [
              "设置位：val |= (1 << n)",
              "清除位：val &= ~(1 << n)",
              "测试位：val & (1 << n)",
              "提取字段：(val & MASK) >> SHIFT",
              "GENMASK(h, l) 生成从 l 到 h 位的掩码"
],
          },
          diagram: {
            title: "GPU \u5bc4\u5b58\u5668\u4f4d\u57df\u64cd\u4f5c",
            content: `GRBM_STATUS 寄存器 (32位):
Bit 31    Bit 16    Bit 8     Bit 0
  |         |         |         |
  v         v         v         v
+----+----+----+----+----+----+----+----+
| ME | PFP| BCI| SX | TA | TC |GUI |IDLE|
+----+----+----+----+----+----+----+----+
  31   30   27   26   14   13   2    0

读取 GUI_ACTIVE 位 (bit 2):
  val = RREG32(mmGRBM_STATUS)
  gui_active = (val & GRBM_STATUS__GUI_ACTIVE_MASK)
             >> GRBM_STATUS__GUI_ACTIVE__SHIFT

设置 SOFT_RESET 位 (bit 20):
  val = RREG32(mmGRBM_SOFT_RESET)
  val |= GRBM_SOFT_RESET__SOFT_RESET_CP_MASK
  WREG32(mmGRBM_SOFT_RESET, val)`,
            caption: "GPU \u5bc4\u5b58\u5668\u4e2d\u7684\u6bcf\u4e2a\u4f4d\u57df\u90fd\u6709\u5bf9\u5e94\u7684 MASK \u548c SHIFT \u5b8f\uff0c\u7528\u4e8e\u7cbe\u786e\u8bfb\u5199\u3002",
          },
          codeWalk: {
            title: "amdgpu \u4e2d\u7684\u5bc4\u5b58\u5668\u8bbf\u95ee\u6a21\u5f0f",
            file: "drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c",
            language: "c",
            code: `/* 1. 读取寄存器 */
u32 tmp = RREG32_SOC15(GC, 0, regCP_MEC_CNTL);

/* 2. 修改特定位域（不影响其他位）*/
tmp = REG_SET_FIELD(tmp, CP_MEC_CNTL, MEC_ME1_HALT, 0); /* 清除 HALT 位 */
tmp = REG_SET_FIELD(tmp, CP_MEC_CNTL, MEC_ME2_HALT, 0);

/* 3. 写回寄存器 */
WREG32_SOC15(GC, 0, regCP_MEC_CNTL, tmp);

/* REG_SET_FIELD 宏的实现 */
#define REG_SET_FIELD(orig_val, reg, field, field_val) \\
    (((orig_val) & ~REG_FIELD_MASK(reg, field)) | \\
     (((field_val) << reg##__##field##__SHIFT) & \\
      REG_FIELD_MASK(reg, field)))

/* 等待寄存器某位变为特定值 */
r = SOC15_WAIT_ON_RREG(GC, 0, regGRBM_STATUS,
    0, GRBM_STATUS__GUI_ACTIVE_MASK);
if (r)
    dev_err(adev->dev, "GPU not idle after reset\n");`,
            annotations: [
              "RREG32_SOC15 读取指定 IP 块（GC=Graphics Core）的寄存器",
              "REG_SET_FIELD 宏安全地修改单个位域，不影响其他位",
              "WREG32_SOC15 将修改后的值写回寄存器",
              "SOC15_WAIT_ON_RREG 轮询等待寄存器某位变为期望值，用于等待硬件操作完成"
],
            explanation: "amdgpu \u9a71\u52a8\u4e2d\u6240\u6709\u5bc4\u5b58\u5668\u8bbf\u95ee\u90fd\u901a\u8fc7\u8fd9\u4e9b\u5b8f\u8fdb\u884c\uff0c\u800c\u4e0d\u662f\u76f4\u63a5\u64cd\u4f5c\u5185\u5b58\u5730\u5740\u3002\u8fd9\u6837\u505a\u7684\u597d\u5904\u662f\uff1a1\uff09\u4ee3\u7801\u53ef\u8bfb\u6027\u597d\uff0c\u5bc4\u5b58\u5668\u540d\u79f0\u76f4\u63a5\u4f53\u73b0\u5728\u4ee3\u7801\u4e2d\uff1b2\uff09\u5b8f\u5185\u90e8\u5904\u7406\u4e86 MMIO \u7684\u5185\u5b58\u5c4f\u969c\uff1b3\uff09\u53ef\u4ee5\u5728\u8c03\u8bd5\u6a21\u5f0f\u4e0b\u8bb0\u5f55\u6240\u6709\u5bc4\u5b58\u5668\u8bbf\u95ee\u3002",
          },
          miniLab: {
            title: "\u4f4d\u64cd\u4f5c\u7ec3\u4e60\uff1a\u89e3\u6790 GPU \u72b6\u6001\u5bc4\u5b58\u5668",
            objective: "\u7528 C \u7a0b\u5e8f\u6a21\u62df GPU \u72b6\u6001\u5bc4\u5b58\u5668\u7684\u8bfb\u5199\u64cd\u4f5c\uff0c\u7406\u89e3\u4f4d\u64cd\u4f5c\u5728\u9a71\u52a8\u4e2d\u7684\u5e94\u7528",
            setup: "mkdir -p ~/amd-labs/1-1-3 && cd ~/amd-labs/1-1-3",
            language: "c",
            code: `#include <stdio.h>
#include <stdint.h>

/* 模拟 GRBM_STATUS 寄存器 */
#define GRBM_STATUS__CMDFIFO_AVAIL_MASK    0x0000001FL
#define GRBM_STATUS__CMDFIFO_AVAIL__SHIFT  0
#define GRBM_STATUS__GUI_ACTIVE_MASK       0x80000000L
#define GRBM_STATUS__GUI_ACTIVE__SHIFT     31
#define GRBM_STATUS__CP_BUSY_MASK          0x20000000L
#define GRBM_STATUS__CP_BUSY__SHIFT        29

#define REG_GET_FIELD(val, mask, shift) (((val) & (mask)) >> (shift))
#define REG_SET_FIELD(val, mask, shift, fval) \\
    (((val) & ~(mask)) | (((fval) << (shift)) & (mask)))

int main() {
    /* 模拟一个 GPU 忙碌的状态值 */
    uint32_t grbm_status = 0xA0000010;
    printf("GRBM_STATUS = 0x%08X\n", grbm_status);
    printf("CMDFIFO_AVAIL = %u\n",
        REG_GET_FIELD(grbm_status, GRBM_STATUS__CMDFIFO_AVAIL_MASK,
                      GRBM_STATUS__CMDFIFO_AVAIL__SHIFT));
    printf("GUI_ACTIVE = %u\n",
        REG_GET_FIELD(grbm_status, GRBM_STATUS__GUI_ACTIVE_MASK,
                      GRBM_STATUS__GUI_ACTIVE__SHIFT));
    printf("CP_BUSY = %u\n",
        REG_GET_FIELD(grbm_status, GRBM_STATUS__CP_BUSY_MASK,
                      GRBM_STATUS__CP_BUSY__SHIFT));
    return 0;
}`,
            steps: [
              "保存为 lab.c，编译运行：gcc -o lab lab.c && ./lab",
              "解释输出：0xA0000010 的各个位域分别代表什么？",
              "修改 grbm_status 值，使 GUI_ACTIVE=0（GPU 空闲）",
              "挑战：实现一个函数，等待 GUI_ACTIVE 变为 0（轮询）"
],
            expectedOutput: `GRBM_STATUS = 0xA0000010
CMDFIFO_AVAIL = 16
GUI_ACTIVE = 1
CP_BUSY = 0`,
            hint: "0xA0000010 = 1010 0000 0000 0000 0000 0000 0001 0000 (\u4e8c\u8fdb\u5236)\u3002bit 31 = 1 (GUI_ACTIVE)\uff0cbit 29 = 0 (CP_BUSY)\uff0cbits 4:0 = 10000 = 16 (CMDFIFO_AVAIL)\u3002",
          },
          debugExercise: {
            title: "\u627e\u51fa\u8fd9\u6bb5\u4ee3\u7801\u4e2d\u7684 Bug",
            description: "\u4e0b\u9762\u7684\u4ee3\u7801\u8bd5\u56fe\u6e05\u9664 GPU \u72b6\u6001\u5bc4\u5b58\u5668\u7684\u67d0\u4e2a\u4f4d\uff0c\u4f46\u7ed3\u679c\u4e0d\u6b63\u786e\u3002",
            buggyCode: `uint32_t val = RREG32(mmGRBM_SOFT_RESET);
/* BUG: 试图清除 bit 20 */
val = val & 20;
WREG32(mmGRBM_SOFT_RESET, val);`,
            language: "c",
            question: "\u8fd9\u6bb5\u4ee3\u7801\u6709\u4ec0\u4e48\u95ee\u9898\uff1f\u4f1a\u5bfc\u81f4\u4ec0\u4e48\u540e\u679c\uff1f",
            hint: "val & 20 \u4e0d\u662f\u6e05\u9664 bit 20\uff0c\u800c\u662f\u53ea\u4fdd\u7559 bit 2 \u548c bit 4\uff08\u56e0\u4e3a 20 = 0b10100\uff09\u3002\u6e05\u9664 bit n \u7684\u6b63\u786e\u65b9\u5f0f\u662f val &= ~(1 << n)\u3002",
            answer: "\u6b63\u786e\u5199\u6cd5\uff1aval &= ~(1 << 20) \u6216 val &= ~GRBM_SOFT_RESET__SOFT_RESET_CP_MASK\u3002val & 20 \u5b9e\u9645\u4e0a\u662f val & 0x14\uff08\u4e8c\u8fdb\u5236 10100\uff09\uff0c\u8fd9\u4f1a\u6e05\u9664\u9664 bit 2 \u548c bit 4 \u4e4b\u5916\u7684\u6240\u6709\u4f4d\uff0c\u5b8c\u5168\u7834\u574f\u4e86\u5bc4\u5b58\u5668\u7684\u503c\u3002",
          },
          interviewQ: {
            question: "\u5728 amdgpu \u9a71\u52a8\u4e2d\uff0c\u4e3a\u4ec0\u4e48\u4f7f\u7528 RREG32/WREG32 \u5b8f\u800c\u4e0d\u662f\u76f4\u63a5\u7528 readl/writel \u8bbf\u95ee\u5bc4\u5b58\u5668\uff1f",
            difficulty: "easy",
            hint: "\u8003\u8651\u4ee3\u7801\u53ef\u8bfb\u6027\u3001\u8c03\u8bd5\u80fd\u529b\u548c\u786c\u4ef6\u62bd\u8c61\u5c42\u7684\u8bbe\u8ba1\u3002",
            answer: "RREG32/WREG32 \u5b8f\u63d0\u4f9b\u4e86\u591a\u5c42\u62bd\u8c61\uff1a1\uff09\u53ef\u8bfb\u6027\uff1a\u5b8f\u540d\u79f0\u76f4\u63a5\u5bf9\u5e94\u5bc4\u5b58\u5668\u540d\u79f0\uff0c\u4ee3\u7801\u81ea\u6587\u6863\u5316\uff1b2\uff09\u8c03\u8bd5\u652f\u6301\uff1a\u5728 DEBUG \u6a21\u5f0f\u4e0b\u53ef\u4ee5\u8bb0\u5f55\u6240\u6709\u5bc4\u5b58\u5668\u8bbf\u95ee\uff0c\u65b9\u4fbf\u8ffd\u8e2a GPU hang \u95ee\u9898\uff1b3\uff09\u786c\u4ef6\u7248\u672c\u9002\u914d\uff1a\u4e0d\u540c GPU \u4e16\u4ee3\u7684\u5bc4\u5b58\u5668\u504f\u79fb\u91cf\u4e0d\u540c\uff0c\u5b8f\u5185\u90e8\u5904\u7406\u4e86\u8fd9\u4e9b\u5dee\u5f02\uff1b4\uff09MMIO \u5b89\u5168\uff1a\u5185\u90e8\u5305\u542b\u4e86\u5fc5\u8981\u7684\u5185\u5b58\u5c4f\u969c\uff1b5\uff09\u9519\u8bef\u68c0\u6d4b\uff1a\u53ef\u4ee5\u5728\u5b8f\u5185\u90e8\u6dfb\u52a0\u5bc4\u5b58\u5668\u5730\u5740\u8303\u56f4\u68c0\u67e5\u3002",
            amdContext: "\u5728 GPU hang \u8c03\u8bd5\u65f6\uff0camdgpu \u9a71\u52a8\u6709\u4e00\u4e2a register dump \u529f\u80fd\uff0c\u4f1a\u6253\u5370\u6240\u6709\u5173\u952e\u5bc4\u5b58\u5668\u7684\u503c\u3002\u8fd9\u4e2a\u529f\u80fd\u4f9d\u8d56\u4e8e RREG32 \u5b8f\u7684\u7edf\u4e00\u63a5\u53e3\u3002AMD \u9762\u8bd5\u4e2d\u7ecf\u5e38\u95ee\u5230\u5982\u4f55\u8c03\u8bd5 GPU hang\uff0c\u7406\u89e3\u5bc4\u5b58\u5668\u8bbf\u95ee\u673a\u5236\u662f\u57fa\u7840\u3002",
          },
        },
        {
          id: "1-1-4",
          number: "1.1.4",
          title: "\u539f\u5b50\u64cd\u4f5c\u4e0e\u5185\u5b58\u5e8f",
          titleEn: "Atomic Operations & Memory Ordering",
          duration: 20,
          tags: ["C", "atomic", "memory-order", "concurrency"],
          concept: {
            summary: "\u5728\u591a\u6838\u7cfb\u7edf\u4e2d\uff0c\u666e\u901a\u7684\u8bfb-\u6539-\u5199\u64cd\u4f5c\u4e0d\u662f\u539f\u5b50\u7684\uff0c\u53ef\u80fd\u5bfc\u81f4\u7ade\u6001\u6761\u4ef6\u3002\u539f\u5b50\u64cd\u4f5c\u548c\u5185\u5b58\u5c4f\u969c\u662f\u9a71\u52a8\u5e76\u53d1\u5b89\u5168\u7684\u57fa\u7840\u3002",
            explanation: [
              "在多核 CPU 上，两个核心可能同时执行 val++ 操作。这个操作实际上是三步：读取 val、加 1、写回 val。如果两个核心同时读取到相同的值，各自加 1 后写回，最终结果只加了 1 而不是 2。这就是竞态条件（race condition）。",
              "原子操作（atomic operations）保证整个读-改-写过程不可被中断。Linux 内核提供了 atomic_t 类型和对应的 atomic_read()、atomic_set()、atomic_inc()、atomic_dec_and_test() 等函数，这些操作在硬件层面保证了原子性。",
              "内存序（memory ordering）是一个更深层的问题：编译器和 CPU 都可能对内存访问进行重排序以提升性能。在单线程程序中这没有问题，但在多线程或驱动与硬件交互时，重排序可能导致严重的 bug。内存屏障（memory barrier）用于阻止这种重排序。",
              "在 amdgpu 驱动中，原子操作用于管理 GPU 引用计数（如 amdgpu_bo 的引用计数）、跟踪待处理的 GPU 命令数量、以及在 CPU 和 GPU 之间同步状态。理解这些机制是理解驱动并发模型的关键。"
],
            keyPoints: [
              "atomic_t 类型保证读-改-写操作的原子性",
              "atomic_inc_return() 返回操作后的新值",
              "atomic_dec_and_test() 减 1 并检查是否变为 0（用于引用计数）",
              "smp_mb() 是完整内存屏障，smp_rmb()/smp_wmb() 是单向屏障",
              "READ_ONCE()/WRITE_ONCE() 防止编译器优化掉看似冗余的内存访问"
],
          },
          diagram: {
            title: "\u7ade\u6001\u6761\u4ef6\u4e0e\u539f\u5b50\u64cd\u4f5c\u5bf9\u6bd4",
            content: `竞态条件（非原子操作）:
  CPU 0              CPU 1
  ─────────────────  ─────────────────
  read val (=5)      read val (=5)
  val = 5 + 1 = 6    val = 5 + 1 = 6
  write val = 6      write val = 6
  结果: val = 6 (错误! 应该是 7)

原子操作（正确）:
  CPU 0              CPU 1
  ─────────────────  ─────────────────
  LOCK               等待锁
  read val (=5)      |
  val = 5 + 1 = 6    |
  write val = 6      |
  UNLOCK             LOCK
                     read val (=6)
                     val = 6 + 1 = 7
                     write val = 7
                     UNLOCK
  结果: val = 7 (正确!)`,
            caption: "\u539f\u5b50\u64cd\u4f5c\u901a\u8fc7\u786c\u4ef6\u9501\u603b\u7ebf\u4fdd\u8bc1\u8bfb-\u6539-\u5199\u7684\u4e0d\u53ef\u5206\u5272\u6027\uff0c\u907f\u514d\u7ade\u6001\u6761\u4ef6\u3002",
          },
          codeWalk: {
            title: "amdgpu \u4e2d\u7684\u539f\u5b50\u64cd\u4f5c\u4f7f\u7528",
            file: "drivers/gpu/drm/amd/amdgpu/amdgpu_fence.c",
            language: "c",
            code: `/* amdgpu_fence.c - GPU fence 的引用计数管理 */

/* 1. 原子引用计数 */
struct amdgpu_fence {
    struct dma_fence base;  /* 包含 refcount: atomic_t */
    struct amdgpu_ring *ring;
    uint64_t seq;
};

/* 2. 增加引用计数 */
struct amdgpu_fence *amdgpu_fence_ref(struct amdgpu_fence *fence)
{
    dma_fence_get(&fence->base);  /* 内部调用 atomic_inc */
    return fence;
}

/* 3. 减少引用计数，为 0 时释放 */
void amdgpu_fence_unref(struct amdgpu_fence **fence)
{
    struct amdgpu_fence *tmp = *fence;
    *fence = NULL;
    if (tmp)
        dma_fence_put(&tmp->base);  /* atomic_dec_and_test + 释放 */
}

/* 4. 等待 GPU 完成（内存屏障保证顺序）*/
int amdgpu_fence_wait(struct amdgpu_fence *fence, bool intr)
{
    long r = dma_fence_wait(&fence->base, intr);
    /* smp_mb() 确保 fence 完成后的内存访问不会被重排到 wait 之前 */
    smp_mb();
    return r < 0 ? r : 0;
}`,
            annotations: [
              "dma_fence 内部包含 atomic_t refcount，保证引用计数的线程安全",
              "dma_fence_get 内部调用 atomic_inc_not_zero，安全地增加引用计数",
              "dma_fence_put 内部调用 atomic_dec_and_test，当计数为 0 时触发释放",
              "smp_mb() 内存屏障确保 GPU 完成的通知在 CPU 读取 GPU 输出数据之前可见"
],
            explanation: "GPU fence \u662f CPU \u7b49\u5f85 GPU \u5b8c\u6210\u64cd\u4f5c\u7684\u6838\u5fc3\u673a\u5236\u3002amdgpu \u9a71\u52a8\u4e2d\uff0c\u6bcf\u4e2a\u63d0\u4ea4\u7ed9 GPU \u7684\u547d\u4ee4\u90fd\u5173\u8054\u4e00\u4e2a fence\u3002\u5f53 GPU \u5b8c\u6210\u547d\u4ee4\u540e\uff0c\u4f1a\u901a\u8fc7\u4e2d\u65ad\u901a\u77e5 CPU\uff0cCPU \u4fa7\u7684 fence \u7b49\u5f85\u51fd\u6570\u4f1a\u8fd4\u56de\u3002\u6574\u4e2a\u8fc7\u7a0b\u9700\u8981\u539f\u5b50\u64cd\u4f5c\u548c\u5185\u5b58\u5c4f\u969c\u6765\u4fdd\u8bc1\u6b63\u786e\u6027\u3002",
          },
          miniLab: {
            title: "\u539f\u5b50\u64cd\u4f5c\u5b9e\u9a8c",
            objective: "\u89c2\u5bdf\u7ade\u6001\u6761\u4ef6\uff0c\u7136\u540e\u7528\u539f\u5b50\u64cd\u4f5c\u4fee\u590d\u5b83",
            setup: "mkdir -p ~/amd-labs/1-1-4 && cd ~/amd-labs/1-1-4",
            language: "c",
            code: `#include <stdio.h>
#include <pthread.h>
#include <stdatomic.h>

#define NUM_THREADS 4
#define ITERATIONS  100000

/* 非原子计数器（有竞态条件）*/
int unsafe_counter = 0;

/* 原子计数器（线程安全）*/
atomic_int safe_counter = 0;

void *unsafe_increment(void *arg) {
    for (int i = 0; i < ITERATIONS; i++)
        unsafe_counter++;  /* 竞态条件! */
    return NULL;
}

void *safe_increment(void *arg) {
    for (int i = 0; i < ITERATIONS; i++)
        atomic_fetch_add(&safe_counter, 1);  /* 原子操作 */
    return NULL;
}

int main() {
    pthread_t threads[NUM_THREADS];
    int expected = NUM_THREADS * ITERATIONS;

    /* 测试非原子版本 */
    for (int i = 0; i < NUM_THREADS; i++)
        pthread_create(&threads[i], NULL, unsafe_increment, NULL);
    for (int i = 0; i < NUM_THREADS; i++)
        pthread_join(threads[i], NULL);
    printf("Unsafe: expected=%d, got=%d, lost=%d\n",
        expected, unsafe_counter, expected - unsafe_counter);

    /* 测试原子版本 */
    for (int i = 0; i < NUM_THREADS; i++)
        pthread_create(&threads[i], NULL, safe_increment, NULL);
    for (int i = 0; i < NUM_THREADS; i++)
        pthread_join(threads[i], NULL);
    printf("Safe:   expected=%d, got=%d, lost=%d\n",
        expected, atomic_load(&safe_counter), expected - atomic_load(&safe_counter));
    return 0;
}`,
            steps: [
              "保存为 lab.c，编译运行：gcc -o lab lab.c -lpthread && ./lab",
              "观察 unsafe_counter 的结果：每次运行都不同，且小于期望值",
              "观察 safe_counter 的结果：每次运行都等于期望值",
              "多运行几次，观察 unsafe 版本的不稳定性",
              "思考：在内核驱动中，哪些数据需要用原子操作保护？"
],
            expectedOutput: `Unsafe: expected=400000, got=312847, lost=87153
Safe:   expected=400000, got=400000, lost=0`,
            hint: "unsafe \u7248\u672c\u7684\u7ed3\u679c\u6bcf\u6b21\u8fd0\u884c\u90fd\u4e0d\u540c\uff0c\u56e0\u4e3a\u7ade\u6001\u6761\u4ef6\u7684\u53d1\u751f\u662f\u4e0d\u786e\u5b9a\u7684\u3002safe \u7248\u672c\u7684\u7ed3\u679c\u603b\u662f\u7cbe\u786e\u7684 400000\u3002",
          },
          debugExercise: {
            title: "\u627e\u51fa\u8fd9\u6bb5\u4ee3\u7801\u4e2d\u7684 Bug",
            description: "\u4e0b\u9762\u7684\u4ee3\u7801\u8bd5\u56fe\u5b9e\u73b0\u4e00\u4e2a\u7b80\u5355\u7684 GPU \u5f15\u7528\u8ba1\u6570\uff0c\u4f46\u5728\u591a\u7ebf\u7a0b\u73af\u5883\u4e0b\u4f1a\u51fa\u73b0\u95ee\u9898\u3002",
            buggyCode: `struct gpu_bo {
    int refcount;  /* BUG: 应该是 atomic_t */
    void *vaddr;
};

void gpu_bo_ref(struct gpu_bo *bo) {
    bo->refcount++;  /* 竞态条件! */
}

void gpu_bo_unref(struct gpu_bo *bo) {
    if (--bo->refcount == 0)  /* 竞态条件! */
        kfree(bo);
}`,
            language: "c",
            question: "\u8fd9\u6bb5\u4ee3\u7801\u6709\u4ec0\u4e48\u95ee\u9898\uff1f\u4f1a\u5bfc\u81f4\u4ec0\u4e48\u540e\u679c\uff1f",
            hint: "\u5982\u679c\u4e24\u4e2a\u7ebf\u7a0b\u540c\u65f6\u8c03\u7528 gpu_bo_unref\uff0c\u90fd\u53ef\u80fd\u770b\u5230 refcount \u4ece 1 \u53d8\u4e3a 0\uff0c\u7136\u540e\u90fd\u8c03\u7528 kfree\uff0c\u5bfc\u81f4 double free\u3002",
            answer: "\u5c06 refcount \u6539\u4e3a atomic_t\uff0c\u4f7f\u7528 atomic_inc() \u548c atomic_dec_and_test() \u6765\u4fdd\u8bc1\u539f\u5b50\u6027\u3002\u5728\u5185\u6838\u4e2d\uff0c\u8fd9\u901a\u5e38\u901a\u8fc7 kref \u673a\u5236\u5b9e\u73b0\uff1akref_get() \u589e\u52a0\u5f15\u7528\uff0ckref_put() \u51cf\u5c11\u5f15\u7528\u5e76\u5728\u4e3a 0 \u65f6\u8c03\u7528\u91ca\u653e\u51fd\u6570\u3002",
          },
          interviewQ: {
            question: "\u5728 amdgpu \u9a71\u52a8\u4e2d\uff0cGPU buffer object\uff08BO\uff09\u7684\u751f\u547d\u5468\u671f\u662f\u5982\u4f55\u7ba1\u7406\u7684\uff1f\u4e3a\u4ec0\u4e48\u9700\u8981\u5f15\u7528\u8ba1\u6570\uff1f",
            difficulty: "medium",
            hint: "\u8003\u8651 GPU BO \u53ef\u80fd\u88ab\u591a\u4e2a\u8fdb\u7a0b\u3001\u591a\u4e2a GPU \u547d\u4ee4\u540c\u65f6\u5f15\u7528\u7684\u60c5\u51b5\u3002",
            answer: "amdgpu_bo \u4f7f\u7528 ttm_bo_reference() \u548c ttm_bo_unref() \u7ba1\u7406\u5f15\u7528\u8ba1\u6570\uff08\u5185\u90e8\u4f7f\u7528 kref\uff09\u3002\u9700\u8981\u5f15\u7528\u8ba1\u6570\u7684\u539f\u56e0\uff1a1\uff09\u4e00\u4e2a BO \u53ef\u80fd\u88ab\u591a\u4e2a\u8fdb\u7a0b\u7684\u547d\u4ee4\u961f\u5217\u540c\u65f6\u5f15\u7528\uff1b2\uff09CPU \u53ef\u80fd\u5728 GPU \u8fd8\u5728\u4f7f\u7528 BO \u65f6\u5c1d\u8bd5\u91ca\u653e\u5b83\uff1b3\uff09\u591a\u4e2a GPU ring \u53ef\u80fd\u540c\u65f6\u4f7f\u7528\u540c\u4e00\u4e2a BO\u3002\u5f15\u7528\u8ba1\u6570\u786e\u4fdd\u53ea\u6709\u5f53\u6240\u6709\u7528\u6237\u90fd\u91ca\u653e\u5f15\u7528\u540e\uff0cBO \u624d\u4f1a\u88ab\u771f\u6b63\u91ca\u653e\uff0c\u907f\u514d use-after-free \u95ee\u9898\u3002",
            amdContext: "amdgpu_bo \u7684\u751f\u547d\u5468\u671f\u7ba1\u7406\u662f AMD \u9762\u8bd5\u7684\u5e38\u89c1\u8bdd\u9898\u3002\u9762\u8bd5\u5b98\u901a\u5e38\u4f1a\u95ee\uff1a\u5982\u679c GPU \u8fd8\u5728\u4f7f\u7528\u4e00\u4e2a BO\uff0c\u4f46\u7528\u6237\u7a7a\u95f4\u5df2\u7ecf close \u4e86 fd\uff0c\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f\u7b54\u6848\u662f\uff1a\u5f15\u7528\u8ba1\u6570\u786e\u4fdd BO \u4e0d\u4f1a\u88ab\u7acb\u5373\u91ca\u653e\uff0c\u76f4\u5230 GPU fence \u5b8c\u6210\u540e\u624d\u4f1a\u51cf\u5c11\u5f15\u7528\u8ba1\u6570\u5e76\u6700\u7ec8\u91ca\u653e\u3002",
          },
        },
        {
          id: "1-1-5",
          number: "1.1.5",
          title: "\u81ea\u65cb\u9501\u4e0e\u4e92\u65a5\u9501",
          titleEn: "Spinlock vs Mutex",
          duration: 20,
          tags: ["C", "spinlock", "mutex", "locking", "concurrency"],
          concept: {
            summary: "\u5185\u6838\u63d0\u4f9b\u4e24\u79cd\u4e3b\u8981\u7684\u4e92\u65a5\u673a\u5236\uff1a\u81ea\u65cb\u9501\uff08spinlock\uff09\u7528\u4e8e\u77ed\u65f6\u95f4\u3001\u4e0d\u53ef\u7761\u7720\u7684\u4e34\u754c\u533a\uff1b\u4e92\u65a5\u9501\uff08mutex\uff09\u7528\u4e8e\u53ef\u80fd\u7761\u7720\u7684\u8f83\u957f\u4e34\u754c\u533a\u3002\u9009\u62e9\u9519\u8bef\u4f1a\u5bfc\u81f4\u6b7b\u9501\u6216\u6027\u80fd\u95ee\u9898\u3002",
            explanation: [
              "自旋锁（spinlock）：当一个线程尝试获取已被占用的自旋锁时，它会在 CPU 上忙等待（spin），不断检查锁是否被释放。这意味着：1）持有自旋锁的代码不能睡眠（否则其他等待的 CPU 会一直空转）；2）自旋锁适合非常短的临界区（微秒级）；3）在中断处理程序中必须使用自旋锁，因为中断上下文不能睡眠。",
              "互斥锁（mutex）：当一个线程尝试获取已被占用的互斥锁时，它会被放入等待队列并进入睡眠状态，让出 CPU 给其他任务。当锁被释放时，等待的线程会被唤醒。互斥锁适合较长的临界区，但不能在中断上下文中使用。",
              "在 amdgpu 驱动中，两种锁都被大量使用。例如，amdgpu_device 结构体中的 ring->ring_lock 是自旋锁，用于保护 ring buffer 的写指针（非常短的操作）；而 adev->mn_lock 是互斥锁，用于保护需要较长时间的内存通知操作。",
              "一个常见的错误是在持有自旋锁时调用可能睡眠的函数（如 kmalloc with GFP_KERNEL、copy_from_user 等）。这会导致内核 BUG，因为睡眠会让其他 CPU 一直自旋，造成系统挂起。"
],
            keyPoints: [
              "spinlock：忙等待，不可睡眠，适合中断上下文和极短临界区",
              "mutex：睡眠等待，可睡眠，不能在中断上下文使用",
              "spin_lock_irqsave() 在获取锁的同时禁用本地中断，防止死锁",
              "lockdep 是内核的锁依赖检测工具，可以在运行时检测潜在死锁",
              "持有 spinlock 时不能调用任何可能睡眠的函数"
],
          },
          diagram: {
            title: "\u81ea\u65cb\u9501 vs \u4e92\u65a5\u9501\u7684\u884c\u4e3a\u5bf9\u6bd4",
            content: `自旋锁（Spinlock）:
  CPU 0 (持有锁)    CPU 1 (等待锁)
  ─────────────     ─────────────────────
  spin_lock()       spin_lock()  <- 开始自旋
  [临界区]           while(!lock) { /* 忙等 */ }
  [临界区]           while(!lock) { /* 忙等 */ }
  spin_unlock()     获得锁! 进入临界区
  CPU 1 一直占用 CPU 资源!

互斥锁（Mutex）:
  CPU 0 (持有锁)    CPU 1 (等待锁)
  ─────────────     ─────────────────────
  mutex_lock()      mutex_lock()  <- 进入睡眠
  [临界区]           [CPU 1 睡眠，让出 CPU]
  [临界区]           [CPU 1 睡眠]
  mutex_unlock()    [CPU 1 被唤醒]
                    获得锁! 进入临界区
  CPU 1 不占用 CPU 资源，但有唤醒开销`,
            caption: "\u81ea\u65cb\u9501\u9002\u5408\u6781\u77ed\u7684\u4e34\u754c\u533a\uff08< 1\u03bcs\uff09\uff0c\u4e92\u65a5\u9501\u9002\u5408\u8f83\u957f\u7684\u4e34\u754c\u533a\uff08> 1\u03bcs\uff09\u3002",
          },
          codeWalk: {
            title: "amdgpu \u4e2d\u7684\u9501\u4f7f\u7528\u6a21\u5f0f",
            file: "drivers/gpu/drm/amd/amdgpu/amdgpu_ring.c",
            language: "c",
            code: `/* 1. 自旋锁：保护 ring buffer 写指针（极短临界区）*/
int amdgpu_ring_alloc(struct amdgpu_ring *ring, unsigned ndw)
{
    /* spin_lock 保护 wptr 的更新 */
    spin_lock(&ring->ring_lock);
    if (ring->count_dw < ndw) {
        spin_unlock(&ring->ring_lock);
        return -ENOMEM;
    }
    ring->count_dw -= ndw;
    ring->wptr += ndw;
    spin_unlock(&ring->ring_lock);
    return 0;
}

/* 2. 互斥锁：保护 GPU 初始化（可能睡眠的长操作）*/
int amdgpu_device_init(struct amdgpu_device *adev, ...)
{
    mutex_init(&adev->lock_reset);
    ...
    mutex_lock(&adev->lock_reset);
    r = amdgpu_hw_init(adev);  /* 可能睡眠 */
    mutex_unlock(&adev->lock_reset);
    return r;
}

/* 3. 在中断上下文中必须用 spin_lock_irqsave */
irqreturn_t amdgpu_irq_handler(int irq, void *arg)
{
    unsigned long flags;
    spin_lock_irqsave(&adev->irq.lock, flags);  /* 禁用中断+加锁 */
    /* 处理中断 */
    spin_unlock_irqrestore(&adev->irq.lock, flags);
    return IRQ_HANDLED;
}`,
            annotations: [
              "ring_lock 是 spinlock，因为 ring buffer 写指针的更新只需要几条指令",
              "lock_reset 是 mutex，因为 GPU 初始化可能需要等待硬件响应（可能睡眠）",
              "spin_lock_irqsave 在加锁的同时保存并禁用本地 CPU 的中断，防止中断处理程序与当前代码竞争同一把锁",
              "spin_unlock_irqrestore 恢复之前保存的中断状态"
],
            explanation: "\u9009\u62e9\u6b63\u786e\u7684\u9501\u7c7b\u578b\u662f\u9a71\u52a8\u5f00\u53d1\u7684\u5173\u952e\u6280\u80fd\u3002\u9519\u8bef\u7684\u9009\u62e9\u4f1a\u5bfc\u81f4\uff1a1\uff09\u5728\u4e2d\u65ad\u4e0a\u4e0b\u6587\u4f7f\u7528 mutex \u2192 \u5185\u6838 BUG\uff1b2\uff09\u6301\u6709 spinlock \u65f6\u8c03\u7528 kmalloc(GFP_KERNEL) \u2192 \u53ef\u80fd\u6b7b\u9501\uff1b3\uff09\u5bf9\u6781\u77ed\u64cd\u4f5c\u4f7f\u7528 mutex \u2192 \u4e0d\u5fc5\u8981\u7684\u4e0a\u4e0b\u6587\u5207\u6362\u5f00\u9500\u3002",
          },
          miniLab: {
            title: "\u9501\u7684\u4f7f\u7528\u5b9e\u9a8c",
            objective: "\u7528\u7528\u6237\u7a7a\u95f4\u7684 pthread \u6a21\u62df\u5185\u6838\u7684\u9501\u673a\u5236\uff0c\u7406\u89e3\u81ea\u65cb\u9501\u548c\u4e92\u65a5\u9501\u7684\u6027\u80fd\u5dee\u5f02",
            setup: "mkdir -p ~/amd-labs/1-1-5 && cd ~/amd-labs/1-1-5",
            language: "c",
            code: `#include <stdio.h>
#include <pthread.h>
#include <stdatomic.h>
#include <time.h>

#define ITERATIONS 1000000

/* 模拟自旋锁 */
atomic_flag spinlock = ATOMIC_FLAG_INIT;
void spin_lock(atomic_flag *lock) {
    while (atomic_flag_test_and_set(lock)) { /* 忙等 */ }
}
void spin_unlock(atomic_flag *lock) {
    atomic_flag_clear(lock);
}

/* 互斥锁 */
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

long long spin_counter = 0;
long long mutex_counter = 0;

void *spin_thread(void *arg) {
    for (int i = 0; i < ITERATIONS; i++) {
        spin_lock(&spinlock);
        spin_counter++;
        spin_unlock(&spinlock);
    }
    return NULL;
}

void *mutex_thread(void *arg) {
    for (int i = 0; i < ITERATIONS; i++) {
        pthread_mutex_lock(&mutex);
        mutex_counter++;
        pthread_mutex_unlock(&mutex);
    }
    return NULL;
}

double time_test(void *(*fn)(void *), int nthreads) {
    pthread_t threads[4];
    struct timespec start, end;
    clock_gettime(CLOCK_MONOTONIC, &start);
    for (int i = 0; i < nthreads; i++)
        pthread_create(&threads[i], NULL, fn, NULL);
    for (int i = 0; i < nthreads; i++)
        pthread_join(threads[i], NULL);
    clock_gettime(CLOCK_MONOTONIC, &end);
    return (end.tv_sec - start.tv_sec) * 1000.0 +
           (end.tv_nsec - start.tv_nsec) / 1e6;
}

int main() {
    double t1 = time_test(spin_thread, 2);
    double t2 = time_test(mutex_thread, 2);
    printf("Spinlock:  %.1f ms, counter=%lld\n", t1, spin_counter);
    printf("Mutex:     %.1f ms, counter=%lld\n", t2, mutex_counter);
    return 0;
}`,
            steps: [
              "保存为 lab.c，编译运行：gcc -O2 -o lab lab.c -lpthread && ./lab",
              "比较 spinlock 和 mutex 的性能差异",
              "修改为 4 个线程，观察竞争加剧时的性能变化",
              "思考：在什么情况下 spinlock 比 mutex 更快？"
],
            expectedOutput: `Spinlock:  245.3 ms, counter=2000000
Mutex:     312.7 ms, counter=2000000`,
            hint: "\u5728\u7ade\u4e89\u6fc0\u70c8\u65f6\uff0cspinlock \u56e0\u4e3a\u5fd9\u7b49\u4f1a\u6d88\u8017\u66f4\u591a CPU\uff0c\u4f46\u907f\u514d\u4e86\u4e0a\u4e0b\u6587\u5207\u6362\u7684\u5f00\u9500\u3002\u5bf9\u4e8e\u6781\u77ed\u7684\u4e34\u754c\u533a\uff0cspinlock \u901a\u5e38\u66f4\u5feb\u3002",
          },
          debugExercise: {
            title: "\u627e\u51fa\u8fd9\u6bb5\u4ee3\u7801\u4e2d\u7684 Bug",
            description: "\u4e0b\u9762\u7684\u5185\u6838\u4ee3\u7801\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\u4f1a\u89e6\u53d1\u5185\u6838 BUG\u3002\u627e\u51fa\u95ee\u9898\u6240\u5728\u3002",
            buggyCode: `spinlock_t lock;

void driver_work_handler(struct work_struct *work)
{
    spin_lock(&lock);
    
    /* BUG: kmalloc with GFP_KERNEL 可能睡眠! */
    void *buf = kmalloc(4096, GFP_KERNEL);
    if (!buf) {
        spin_unlock(&lock);
        return;
    }
    
    /* 处理数据 */
    kfree(buf);
    spin_unlock(&lock);
}`,
            language: "c",
            question: "\u8fd9\u6bb5\u4ee3\u7801\u6709\u4ec0\u4e48\u95ee\u9898\uff1f\u4f1a\u5bfc\u81f4\u4ec0\u4e48\u540e\u679c\uff1f",
            hint: "kmalloc(GFP_KERNEL) \u5728\u5185\u5b58\u4e0d\u8db3\u65f6\u53ef\u80fd\u89e6\u53d1\u5185\u5b58\u56de\u6536\uff0c\u8fd9\u4f1a\u5bfc\u81f4\u5f53\u524d\u8fdb\u7a0b\u7761\u7720\u3002\u800c\u5728\u6301\u6709 spinlock \u65f6\u7761\u7720\u662f\u4e0d\u5141\u8bb8\u7684\uff0c\u4f1a\u89e6\u53d1\u5185\u6838 BUG: scheduling while atomic\u3002",
            answer: "\u89e3\u51b3\u65b9\u6848\uff1a1\uff09\u5c06 kmalloc \u79fb\u5230 spin_lock \u4e4b\u524d\uff1b2\uff09\u4f7f\u7528 GFP_ATOMIC \u6807\u5fd7\uff08\u4e0d\u4f1a\u7761\u7720\uff0c\u4f46\u53ef\u80fd\u5931\u8d25\uff09\uff1b3\uff09\u5c06 spinlock \u6539\u4e3a mutex\uff08\u5982\u679c\u8fd9\u4e2a\u51fd\u6570\u4e0d\u5728\u4e2d\u65ad\u4e0a\u4e0b\u6587\u4e2d\u8c03\u7528\uff09\u3002\u6700\u4f73\u5b9e\u8df5\u662f\u5728\u52a0\u9501\u524d\u5206\u914d\u597d\u6240\u6709\u9700\u8981\u7684\u5185\u5b58\u3002",
          },
          interviewQ: {
            question: "\u5728 amdgpu \u9a71\u52a8\u4e2d\uff0c\u4ec0\u4e48\u60c5\u51b5\u4e0b\u5e94\u8be5\u4f7f\u7528 spinlock\uff0c\u4ec0\u4e48\u60c5\u51b5\u4e0b\u5e94\u8be5\u4f7f\u7528 mutex\uff1f\u8bf7\u7ed9\u51fa\u5177\u4f53\u4f8b\u5b50\u3002",
            difficulty: "medium",
            hint: "\u8003\u8651\u4e2d\u65ad\u4e0a\u4e0b\u6587\u3001\u4e34\u754c\u533a\u957f\u5ea6\u548c\u662f\u5426\u53ef\u80fd\u7761\u7720\u3002",
            answer: "\u4f7f\u7528 spinlock \u7684\u573a\u666f\uff1a1\uff09\u4e2d\u65ad\u5904\u7406\u7a0b\u5e8f\uff08irq handler\uff09\u4e2d\uff0c\u56e0\u4e3a\u4e2d\u65ad\u4e0a\u4e0b\u6587\u4e0d\u80fd\u7761\u7720\uff1b2\uff09\u4fdd\u62a4\u6781\u77ed\u7684\u4e34\u754c\u533a\uff0c\u5982 ring buffer \u5199\u6307\u9488\u66f4\u65b0\uff08\u51e0\u6761\u6307\u4ee4\uff09\uff1b3\uff09\u5728 softirq \u6216 tasklet \u4e2d\u3002\u4f7f\u7528 mutex \u7684\u573a\u666f\uff1a1\uff09\u4fdd\u62a4\u53ef\u80fd\u9700\u8981\u7b49\u5f85\u786c\u4ef6\u54cd\u5e94\u7684\u64cd\u4f5c\uff0c\u5982 GPU \u521d\u59cb\u5316\uff1b2\uff09\u4fdd\u62a4\u9700\u8981\u5206\u914d\u5185\u5b58\u7684\u64cd\u4f5c\uff1b3\uff09\u4fdd\u62a4\u7528\u6237\u7a7a\u95f4 ioctl \u5904\u7406\uff08\u53ef\u4ee5\u7761\u7720\uff09\u3002amdgpu \u4e2d\u7684\u4f8b\u5b50\uff1aring->ring_lock\uff08spinlock\uff09\u4fdd\u62a4 ring \u5199\u6307\u9488\uff1badev->lock_reset\uff08mutex\uff09\u4fdd\u62a4 GPU \u91cd\u7f6e\u6d41\u7a0b\u3002",
            amdContext: "AMD \u9762\u8bd5\u4e2d\u7ecf\u5e38\u95ee\u5230\u9501\u7684\u9009\u62e9\uff0c\u7279\u522b\u662f\u5728 GPU hang \u6062\u590d\uff08GPU reset\uff09\u573a\u666f\u4e2d\uff0c\u9700\u8981\u5728\u4e2d\u65ad\u4e0a\u4e0b\u6587\u548c\u8fdb\u7a0b\u4e0a\u4e0b\u6587\u4e4b\u95f4\u534f\u8c03\uff0c\u9501\u7684\u9009\u62e9\u975e\u5e38\u5173\u952e\u3002",
          },
        },
      ],
    },
    {
      id: "1-2",
      number: "1.2",
      title: "Linux \u5de5\u5177\u94fe",
      titleEn: "Linux Toolchain",
      icon: "\ud83d\udd27",
      description: "\u638c\u63e1\u5185\u6838\u5f00\u53d1\u7684\u65e5\u5e38\u5de5\u5177\uff1a\u4ece\u6784\u5efa\u5185\u6838\u6a21\u5757\u5230\u8c03\u8bd5\u548c\u63d0\u4ea4\u8865\u4e01\u3002",
      lessons: [
        {
          id: "1-2-1",
          number: "1.2.1",
          title: "\u5185\u6838\u6e90\u7801\u6811\u7ed3\u6784",
          titleEn: "Kernel Source Tree Structure",
          duration: 10,
          tags: ["kernel", "source", "navigation"],
          concept: {
            summary: "Linux \u5185\u6838\u6e90\u7801\u6811\u6709\u4e25\u683c\u7684\u76ee\u5f55\u7ed3\u6784\uff0c\u4e86\u89e3\u8fd9\u4e2a\u7ed3\u6784\u662f\u5feb\u901f\u5b9a\u4f4d amdgpu \u76f8\u5173\u4ee3\u7801\u7684\u57fa\u7840\u3002",
            explanation: [
              "Linux 内核源码树（kernel source tree）是一个包含数百万行代码的庞大项目。但它有非常清晰的目录结构：arch/ 包含架构相关代码，drivers/ 包含所有驱动，fs/ 包含文件系统，mm/ 包含内存管理，net/ 包含网络协议栈，kernel/ 包含核心调度器和系统调用。",
              "对于 AMD GPU 驱动开发者，最重要的目录是 drivers/gpu/drm/amd/。这个目录包含了 amdgpu 驱动的所有代码，进一步分为 amdgpu/（主驱动）、display/（显示控制器）、amdkfd/（ROCm 内核接口）、pm/（电源管理）等子目录。",
              "内核使用 Kconfig 和 Makefile 系统来管理编译配置。每个目录都有一个 Kconfig 文件（定义配置选项）和一个 Makefile 文件（定义编译规则）。理解这两个文件是添加新文件到内核构建系统的基础。",
              "使用 cscope 或 ctags 等工具可以在内核源码中快速跳转。更现代的方式是使用 clangd 语言服务器（需要先生成 compile_commands.json），这可以在 VS Code 或 Neovim 中提供代码补全和跳转功能。"
],
            keyPoints: [
              "drivers/gpu/drm/amd/ 是 AMD GPU 驱动的根目录",
              "amdgpu/ 包含主驱动，amdkfd/ 包含 ROCm 内核接口",
              "include/uapi/drm/ 包含用户空间可见的 DRM API 头文件",
              "make scripts/clang-tools 生成 compile_commands.json 支持 IDE"
],
          },
          diagram: {
            title: "AMD GPU \u76f8\u5173\u7684\u5185\u6838\u6e90\u7801\u6811\u7ed3\u6784",
            content: `linux/
+-- drivers/
|   +-- gpu/
|       +-- drm/                   <- DRM 子系统
|           +-- amd/               <- AMD GPU 驱动根目录
|           |   +-- amdgpu/        <- 主 GPU 驱动 (你最常看的地方)
|           |   |   +-- amdgpu_device.c  <- 设备初始化
|           |   |   +-- amdgpu_ring.c    <- 命令环形缓冲区
|           |   |   +-- amdgpu_fence.c   <- GPU 同步 fence
|           |   |   +-- amdgpu_vm.c      <- GPU 虚拟内存管理
|           |   |   +-- amdgpu_cs.c      <- 命令提交
|           |   |   +-- display/         <- 显示控制器 (DC)
|           |   +-- amdkfd/      <- ROCm 内核驱动 (KFD)
|           |   +-- pm/          <- 电源管理
|           +-- drm_drv.c        <- DRM 核心
+-- include/
    +-- uapi/drm/
    |   +-- amdgpu_drm.h          <- 用户空间 API
    +-- drm/
        +-- drm_drv.h             <- DRM 内核 API`,
            caption: "AMD GPU \u9a71\u52a8\u4ee3\u7801\u5206\u5e03\u5728 drivers/gpu/drm/amd/ \u4e0b\u7684\u591a\u4e2a\u5b50\u76ee\u5f55\u4e2d\uff0c\u6bcf\u4e2a\u5b50\u76ee\u5f55\u8d1f\u8d23\u4e0d\u540c\u7684\u529f\u80fd\u6a21\u5757\u3002",
          },
          codeWalk: {
            title: "amdgpu \u76ee\u5f55\u7684 Makefile \u2014 \u7406\u89e3\u7f16\u8bd1\u7cfb\u7edf",
            file: "drivers/gpu/drm/amd/amdgpu/Makefile",
            language: "makefile",
            code: `# drivers/gpu/drm/amd/amdgpu/Makefile

# 1. 定义模块名称
obj-$(CONFIG_DRM_AMDGPU) += amdgpu.o

# 2. 列出所有源文件（节选）
amdgpu-y := amdgpu_drv.o \\
            amdgpu_device.o \\
            amdgpu_ring.o \\
            amdgpu_fence.o \\
            amdgpu_vm.o \\
            amdgpu_cs.o \\
            amdgpu_gem.o

# 3. 条件编译（只在支持 ROCm 时编译 KFD 接口）
amdgpu-$(CONFIG_HSA_AMD) += amdgpu_amdkfd.o

# 4. 包含子目录
include $(src)/display/Makefile`,
            annotations: [
              "obj-$(CONFIG_DRM_AMDGPU) 表示只有当内核配置了 DRM_AMDGPU 时才编译这个模块",
              "amdgpu-y 列出了所有需要编译进 amdgpu.ko 的源文件",
              "amdgpu-$(CONFIG_HSA_AMD) 根据 HSA_AMD 配置条件性地添加文件",
              "include 包含子目录的 Makefile，使显示子系统的文件也被编译进来"
],
            explanation: "\u7406\u89e3 Makefile \u662f\u5411 amdgpu \u9a71\u52a8\u6dfb\u52a0\u65b0\u6587\u4ef6\u7684\u57fa\u7840\u3002\u5f53\u4f60\u521b\u5efa\u4e00\u4e2a\u65b0\u7684 .c \u6587\u4ef6\u65f6\uff0c\u9700\u8981\u5c06\u5176\u6dfb\u52a0\u5230 Makefile \u4e2d\u7684 amdgpu-y \u5217\u8868\u91cc\uff0c\u5185\u6838\u6784\u5efa\u7cfb\u7edf\u624d\u4f1a\u7f16\u8bd1\u5b83\u3002",
          },
          miniLab: {
            title: "\u63a2\u7d22 amdgpu \u6e90\u7801\u6811",
            objective: "\u5b66\u4e60\u4f7f\u7528\u547d\u4ee4\u884c\u5de5\u5177\u5feb\u901f\u5bfc\u822a amdgpu \u6e90\u7801\uff0c\u627e\u5230\u5173\u952e\u51fd\u6570\u7684\u5b9a\u4e49",
            setup: "# \u514b\u9686\u5185\u6838\u6e90\u7801\uff08\u53ea\u514b\u9686\u6700\u65b0\u63d0\u4ea4\u8282\u7701\u65f6\u95f4\uff09\ngit clone --depth=1 https://github.com/torvalds/linux.git\ncd linux",
            language: "bash",
            code: `# 1. 查看 amdgpu 目录结构
ls drivers/gpu/drm/amd/amdgpu/ | head -30

# 2. 统计 amdgpu 代码行数
find drivers/gpu/drm/amd/ -name '*.c' | xargs wc -l | tail -1

# 3. 搜索函数定义
grep -rn 'int amdgpu_device_init' drivers/gpu/drm/amd/

# 4. 查找所有调用 amdgpu_ring_alloc 的地方
grep -rn 'amdgpu_ring_alloc' drivers/gpu/drm/amd/ | grep -v '.h:'

# 5. 生成 compile_commands.json（用于 IDE 支持）
make defconfig
bear -- make -j$(nproc) drivers/gpu/drm/amd/

# 6. 用 cscope 建立索引
find drivers/gpu/drm/amd/ -name '*.[ch]' > cscope.files
cscope -b -q -k
# 然后在 vim 中：:cs find g amdgpu_device_init`,
            steps: [
              "克隆内核源码（--depth=1 只获取最新提交，节省时间和空间）",
              "用 ls 查看 amdgpu 目录，了解文件组织方式",
              "用 grep -rn 搜索函数定义，这是最常用的代码导航方式",
              "统计代码行数，感受 amdgpu 驱动的规模",
              "尝试找到 amdgpu_device_init 函数，阅读前 50 行"
],
            expectedOutput: `# ls 输出：amdgpu_device.c, amdgpu_ring.c, amdgpu_fence.c ...
# wc -l 输出：约 500,000 行代码
# grep 输出：drivers/gpu/drm/amd/amdgpu/amdgpu_device.c:1234:int amdgpu_device_init(...)`,
            hint: "grep -rn \u662f\u6700\u5feb\u7684\u4ee3\u7801\u641c\u7d22\u65b9\u5f0f\u3002-r \u8868\u793a\u9012\u5f52\u641c\u7d22\uff0c-n \u663e\u793a\u884c\u53f7\u3002\u5bf9\u4e8e\u5927\u578b\u9879\u76ee\uff0c\u53ef\u4ee5\u7528 ripgrep (rg) \u4ee3\u66ff grep\uff0c\u901f\u5ea6\u5feb 10 \u500d\u4ee5\u4e0a\u3002",
          },
          debugExercise: {
            title: "\u627e\u51fa\u8fd9\u6bb5\u4ee3\u7801\u4e2d\u7684 Bug",
            description: "\u4e00\u4e2a\u5f00\u53d1\u8005\u60f3\u5728 amdgpu \u4e2d\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u8c03\u8bd5\u6587\u4ef6 amdgpu_debug_new.c\uff0c\u4f46\u7f16\u8bd1\u540e\u6ca1\u6709\u88ab\u5305\u542b\u8fdb\u5185\u6838\u6a21\u5757\u3002\u627e\u51fa\u539f\u56e0\u3002",
            buggyCode: `# 开发者创建了文件
touch drivers/gpu/drm/amd/amdgpu/amdgpu_debug_new.c

# 但忘记修改 Makefile
# drivers/gpu/drm/amd/amdgpu/Makefile 中没有添加:
# amdgpu-y += amdgpu_debug_new.o`,
            language: "c",
            question: "\u8fd9\u6bb5\u4ee3\u7801\u6709\u4ec0\u4e48\u95ee\u9898\uff1f\u4f1a\u5bfc\u81f4\u4ec0\u4e48\u540e\u679c\uff1f",
            hint: "\u5185\u6838\u6784\u5efa\u7cfb\u7edf\u53ea\u7f16\u8bd1 Makefile \u4e2d\u660e\u786e\u5217\u51fa\u7684\u6587\u4ef6\u3002\u521b\u5efa .c \u6587\u4ef6\u540e\uff0c\u5fc5\u987b\u5728\u5bf9\u5e94\u7684 Makefile \u4e2d\u6dfb\u52a0 .o \u6587\u4ef6\u624d\u4f1a\u88ab\u7f16\u8bd1\u3002",
            answer: "\u5728 drivers/gpu/drm/amd/amdgpu/Makefile \u4e2d\u7684 amdgpu-y \u5217\u8868\u4e2d\u6dfb\u52a0 amdgpu_debug_new.o\u3002\u7136\u540e\u91cd\u65b0\u8fd0\u884c make drivers/gpu/drm/amd/amdgpu/ \u6765\u7f16\u8bd1\u3002",
          },
          interviewQ: {
            question: "\u5982\u4f55\u5feb\u901f\u627e\u5230 amdgpu \u9a71\u52a8\u4e2d\u5904\u7406 GPU hang \u68c0\u6d4b\u7684\u4ee3\u7801\uff1f\u63cf\u8ff0\u4f60\u7684\u641c\u7d22\u7b56\u7565\u3002",
            difficulty: "easy",
            hint: "\u8003\u8651\u4f7f\u7528 grep \u641c\u7d22\u5173\u952e\u8bcd\uff0c\u4ee5\u53ca\u5982\u4f55\u4ece\u4e00\u4e2a\u51fd\u6570\u8ffd\u8e2a\u5230\u76f8\u5173\u7684\u8c03\u7528\u94fe\u3002",
            answer: "\u641c\u7d22\u7b56\u7565\uff1a1\uff09grep -rn 'gpu_hang\\|gpu hang\\|amdgpu_gpu_recovery' drivers/gpu/drm/amd/ \u627e\u5230\u76f8\u5173\u51fd\u6570\uff1b2\uff09\u627e\u5230 amdgpu_device_gpu_recover() \u51fd\u6570\uff0c\u8fd9\u662f GPU hang \u6062\u590d\u7684\u5165\u53e3\uff1b3\uff09\u67e5\u770b\u8c03\u7528\u5b83\u7684\u5730\u65b9\uff1agrep -rn 'gpu_recover' \u627e\u5230\u89e6\u53d1\u70b9\uff1b4\uff09\u9605\u8bfb amdgpu_job_timedout() \u51fd\u6570\uff0c\u8fd9\u662f\u8d85\u65f6\u68c0\u6d4b\u7684\u5165\u53e3\uff1b5\uff09\u4f7f\u7528 cscope \u6216 ctags \u8ffd\u8e2a\u51fd\u6570\u8c03\u7528\u94fe\u3002\u5173\u952e\u6587\u4ef6\uff1aamdgpu_device.c\uff08\u6062\u590d\u903b\u8f91\uff09\u3001amdgpu_job.c\uff08\u8d85\u65f6\u68c0\u6d4b\uff09\u3002",
            amdContext: "AMD \u9762\u8bd5\u4e2d\u7ecf\u5e38\u95ee\u5230 GPU hang \u7684\u5904\u7406\u6d41\u7a0b\u3002\u4e86\u89e3\u4ee3\u7801\u5728\u6e90\u7801\u6811\u4e2d\u7684\u4f4d\u7f6e\uff0c\u4ee5\u53ca\u5982\u4f55\u5feb\u901f\u5b9a\u4f4d\u76f8\u5173\u4ee3\u7801\uff0c\u662f\u5de5\u7a0b\u5e08\u65e5\u5e38\u5de5\u4f5c\u7684\u57fa\u672c\u6280\u80fd\u3002",
          },
        },
      ],
    },
  ],
  completionChecklist: [
    '能解释指针算术和 container_of 宏的工作原理',
    '能说出结构体对齐和 padding 对驱动的影响',
    '能正确使用位操作读写 GPU 寄存器',
    '能区分 atomic 操作和 spinlock/mutex 的使用场景',
    '能用 make 编译内核模块并用 insmod 加载',
    '能用 printk/dmesg 进行内核调试',
    '能解释 CPU cache line 和 MESI 协议',
    '能说明虚拟内存和页表走读过程',
    '能写出一个简单的 PCI 驱动模板',
    '能使用 git format-patch 生成内核补丁',
  ],
};

export default module1MicroLessons;